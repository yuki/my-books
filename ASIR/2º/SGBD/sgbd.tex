\chapter{Introducción}

Hoy en día es habitual que los datos que usamos estén almacenados en una Base de Datos. Da igual que ese dato lo estemos utilizando desde un navegador web, en una aplicación de móvil o una videojuego. Cada consulta que realicemos al dato y cada posible modificación o eliminación del mismo realizará una petición (consulta o modificación) a un Sistema Gestor de Base de Datos.

Cada consulta realizada, cada petición de actualización o cada eliminación de datos, tendrá que ser procesada por el Gestor de Base de Datos y analizada para comprobar que lo que se va a realizar, como los permisos de quién pide la acción son adecuados, para posteriormente realizar la acción.

Los datos almacenados en una base de datos son de gran importancia en una empresa, por lo que la continuidad del servicio, así como la seguridad de los accesos recae en los administradores de Bases de Datos (DBA o DataBase Administrator) que deberán asegurar que el funcionamiento sea el esperado, así como la gestión de copias de seguridad de los mismos.

A lo largo de esta asignatura recordaremos los conceptos básicos de las bases de datos, comprenderemos la importancia y las funciones que desempeñan un Sistema Gestor de Base de Datos, aprenderemos a administrar el SGBD, crear y gestionar backups así como montar un sistema en \hyperlink{altadisponibilidad}{Alta Disponibilidad}.

\chapter{Repaso}
A modo de repaso rápido de la asignatura Gestión de Bases de Datos, veremos rápidamente unos conceptos que nos deberían ser conocidos.


\section{¿Qué es una Base de Datos?}
Recordemos que una base de datos es un conjunto de datos que suelen pertenecer a un mismo contexto y que está almacenado para poder ser consultado posteriormente. Aunque actualmente una base de datos se asocia a un sistema informático, una biblioteca también puede considerarse una base de datos, ya que almacena libros que se pueden consultar, y el bibliotecario (el que te da acceso a los libros, si es que perteneces a la biblioteca) podría ser el símil del sistema gestor de la base de datos.

Actualmente las bases de datos se encuentran en todos los lugares, no sólo en servidores específicamente creados para ellos. Algunos ejemplos:

\begin{itemize}
    \item Cada vez que usamos una aplicación de móvil, la propia aplicación cuenta con una base de datos interna (aparte de los datos que pueda consultar a bases de datos externas)
    \item Las páginas web que visitamos almacenan datos en pequeñas bases de datos en los propios navegadores que usamos.
    \item Aplicaciones de escritorio que guardan las preferencias del usuario en bases de datos.
\end{itemize}


No todas las bases de datos tienen por qué ser gestionadas por sistemas gestores (como los ejemplos puestos previamente), ya que el acceso a los datos quizá no sea necesario que esté controlado, pero en entornos empresariales es lo habitual.

\section{Tipos de Bases de Datos}
Las bases de datos se pueden clasificar de varias maneras, teniendo en cuenta el contexto que estemos manejando, las necesidades que tengamos, el tipo de datos que estemos utilizando…

Nos vamos a centrar en la clasificación teniendo en cuenta los distintos modelos de administración de los datos, concrétamente en el \textbf{modelo relacional}, aunque veremos otros también utilizados.


\subsection{Bases de datos relacionales}
Es el modelo más utilizado actualmente para representar problemas reales y administrarlos de manera dinámica. El paradigma nació en \textbf{1970} de la mano de \href{https://es.wikipedia.org/wiki/Edgar_Frank_Codd}{Edgar Frank Codd} cuya idea es el uso de “relaciones”.

\begin{wrapfigure}{r}{0.36\linewidth}
    \centering
    \vspace{-15pt}
    \includegraphics[width=\linewidth]{ejemplo_diagrama_E-R_extendido.png}
    \vspace{-30pt}
    \captionof{figure}{\href{https://commons.wikimedia.org/wiki/File:Ejemplo_Diagrama_E-R_extendido.PNG}{Origen: Wikipedia}}
    \vspace{-30pt}
\end{wrapfigure}
En este modelo, el lugar y la forma en que se almacenen los datos no tienen relevancia (que sí tenían otros modelos previos).

Para que una base de datos sea considerada relacional debe de seguir el modelo relacional, por lo que antes de introducir datos, para crear la base de datos \textbf{habremos realizado los pasos necesarios para pasar del modelo entidad-relación al modelo relacional}. Es por ello que hay que acordarse siempre de realizar la \textbf{normalización de la base datos}.

Para este tipo de bases de datos el lenguaje de consultas utilizado es el \textbf{SQL} (en inglés \textit{Structured Query Language}; en castellano: lenguaje de consulta estructurada) el cual abordaremos más adelante.


\subsection{No relacionales}
Antes y después de la aparición del modelo relacional han existido distintos modelos de base de datos (jerárquico, de red, multidimensionales… ), por lo que hay que entender que el relacional no es el único modelo existente, aunque sí el más utilizado.


\subsubsection{Bases de datos Documentales}
Las bases de datos documentales son aquellas que se encargan de almacenar datos de tipo documento, también conocidos como datos semi-estructurados.

En el dato almacenado puede existir una estructura fija, o que puede ser modificada en el tiempo. Normalmente esta información suele estar almacenada en \hyperlink{json}{JSON} o XML.

Este tipo de bases de datos entran dentro de las denominadas \href{https://es.wikipedia.org/wiki/NoSQL}{NoSQL}, cuyos datos no requieren estructuras fijas como tablas y cuyo acceso suele realizarse mediante el sistema “clave-valor”.

Las bases de datos NoSQL están altamente optimizadas para las operaciones recuperar y agregar, y normalmente no ofrecen mucho más que la funcionalidad de almacenar los registros. No suele ser habitual el poder realizar consultas de tipo JOIN, por lo que este tipo de operaciones se realizaría desde la aplicación que realiza las consultas de obtención de datos.

No entraremos en este modelo de base de datos, debido a sus diferencias con el modelo relacional, pero es obligatorio conocer que existen y que son utilizadas en aplicaciones como las redes sociales (por ejemplo).

Algunos ejemplos de gestores NoSQL son: \href{https://es.wikipedia.org/wiki/MongoDB}{MongoDB}, \href{https://es.wikipedia.org/wiki/Elasticsearch}{Elasticsearch}, …


\chapter{Sistemas Gestores de Bases de Datos}
\begin{wrapfigure}{r}{0.17\linewidth}
    \centering
    \vspace{-20pt}
    \includegraphics[width=\linewidth]{Componentes_de_un_base_de_datos.jpg}
    \vspace{-33pt}
    \captionof{figure}{\href{https://commons.wikimedia.org/wiki/File:Componentes_de_un_base_de_datos.jpg}{Origen: Wikipedia}}
    \vspace{-30pt}
\end{wrapfigure}
Un Sistema Gestor de Base de Datos es un conjunto de programas que permiten el almacenamiento, modificación y consulta de datos de una base de datos. Teniendo en cuenta los permisos del solicitante se le otorgarán ciertos privilegios lo que hará que se le permitirá acceder (o no) a ciertas funciones que podrá realizar sobre los datos.

Estos sistemas proporcionan distintas tareas para mantener la integridad de los datos, administrar el acceso y la opción de recuperar información en caso de que el sistema se corrompa.

Tal como se puede ver en la imagen, el ejemplo de uso habitual de un Sistema Gestor de Base de Datos se puede resumir de la siguiente forma:

\begin{itemize}
    \item El usuario se comunica con el SGBD (Sistema Gestor de Base de Datos, o en inglés DBMS: DataBase Management System).
    \item El SGBD comprueba que el usuario tiene permisos para acceder a los datos.
    \item El SGBD conoce cómo están almacenados los datos por lo que hará uso del método de acceso adecuado de cómo se han guardado los datos.
    \item Se recuperan los datos del dispositivo físico concreto donde estén almacenados los datos, teniendo en cuenta los datos pedidos por el usuario y el método de acceso.
    \item Se le entregan los datos al usuario.
\end{itemize}

Todas estas tareas deben de realizarse de la manera más rápida posible, por lo que la optimización de cada una de las partes debe de ser adecuada.


\section{Componentes de un SGBD}
Normalmente un SGBD tiene los siguientes componentes:

\begin{itemize}
    \item El \textbf{motor de la base de datos} acepta peticiones lógicas de los otros subsistemas del SGBD, las convierte en su equivalente físico y accede a la base de datos y diccionario de datos en el dispositivo de almacenamiento.
    \item El \textbf{subsistema de definición de datos} ayuda a crear y mantener el diccionario de datos y define la estructura del fichero que soporta la base de datos.
    \item El \textbf{subsistema de manipulación} de datos ayuda al usuario a añadir, cambiar y borrar información de la base de datos y la consulta para extraer información. El subsistema de manipulación de datos suele ser la interfaz principal del usuario con la base de datos, y normalmente se hace uso del lenguaje SQL.
    \item El \textbf{subsistema de administración} ayuda a gestionar la base de datos ofreciendo funcionalidades como almacenamiento y recuperación, gestión de la seguridad, optimización de preguntas, control de concurrencia y gestión de cambios.
\end{itemize}

Dependiendo del SGBD que utilicemos, podremos contar con otros apartados que vienen incluídos, o programas externos que podremos utilizar para ampliar alguna funcionalidad del mismo.

\section{Modelo ACID de transacciones}
En bases de datos se denomina \textbf{ACID} a las características de los parámetros que permiten clasificar las transacciones de los sistemas de gestión de bases de datos, donde ACID es un acrónimo en inglés de \textit{\textbf{A}tomicity, \textbf{C}onsistency, \textbf{I}solation and \textbf{D}urability} (en castellano: Atomicidad, Consistencia, Aislamiento y Durabilidad).

Las definiciones son:

\begin{itemize}
    \item \textbf{Atomicidad}: Una transacción es una unidad lógica de trabajo que contiene una o varias sentencias SQL. El principio básico de una transacción es el todo o nada, una operación atómica tiene éxito o falla como un todo.
        \begin{itemize}
            \item Un SGBD ha de ser capaz de asegurar la integridad de los datos ante la concurrencia de varios usuarios a la vez.
            \item Un SGBD debe de ser capaz de agrupar varias sentencias SQL,de tal manera que puedan ser validadas (\textbf{commit}) o desechadas (\textbf{rollback}) como una unidad.
            \item \textbf{Ejemplo}: en el caso de una transacción bancaria o se ejecuta tanto el depósito y la deducción o ninguna acción es realizada
        \end{itemize}
    \item \textbf{Consistencia}: (Integridad). Es la propiedad que asegura que sólo se empieza aquello que se puede acabar. Por lo tanto se ejecutan aquellas operaciones que no van a romper las reglas y directrices de Integridad de la base de datos.
        \begin{itemize}
            \item El SGBD debe asegurar que cualquier transacción llevará a la base de datos desde un estado válido a otro también válido.
            \item El SGBD debe asegurar que los datos son exactos y consistentes, es decir que estén siempre intactos, sean siempre los esperados y que de ninguna manera cambian ni se deformen. De esta manera podemos garantizar que la información que se presenta al usuario será siempre la misma.
        \end{itemize}
    \item \textbf{Isolation / Aislamiento}: Esta propiedad asegura que una operación no puede afectar a otras.
        \begin{itemize}
            \item Esto asegura que la realización de dos transacciones sobre la misma información sean independientes y no generen ningún tipo de error.
            \item Esta propiedad define cómo y cuándo los cambios producidos por una operación se hacen visibles para las demás operaciones concurrentes.
            \item El aislamiento puede alcanzarse en distintos niveles, siendo el parámetro esencial a la hora de seleccionar SGBDs.
        \end{itemize}
    \item \textbf{Durabilidad / Persistencia}: Esta propiedad asegura que una vez realizada la operación, ésta persistirá y no se podrá deshacer aunque falle el sistema y que de esta forma los datos sobrevivan.
\end{itemize}

\section{Software SGBD}
Actualmente existen distintos SGBD que podemos instalar en nuestros servidores. Cada uno de ellos cuentan con sus características propias, por lo que tendremos que conocer las necesidades que tenemos a la hora de elegir entre ellas.

\begin{itemize}
    \item \href{https://es.wikipedia.org/wiki/MySQL}{MySQL}: base de datos relacional, desarrollada por Oracle desde que en 2008 ésta se hiciera con Sun Microsystems y de licencia libre (aunque también cuenta con una versión no-libre).
    \item \href{https://es.wikipedia.org/wiki/PostgreSQL}{PostgreSQL}: base de datos relacional, desarrollada por PostgreSQL Global Development Group y de licencia libre.
    \item \href{https://es.wikipedia.org/wiki/Microsoft_SQL_Server}{SQL Server}: base de datos relacional, desarrollada por Microsoft.
    \item \href{https://es.wikipedia.org/wiki/Oracle_Database}{Oracle Database}: base de datos de tipo objeto-relacional desarrollada por Oracle Corporation.
    \item \href{https://en.wikipedia.org/wiki/IBM_Db2_Family}{DB2}: base de datos relacional, desarrollada por IBM.
    \item \href{https://es.wikipedia.org/wiki/MongoDB}{MongoDB}: base de datos documental, desarrollada por MongoDB y de licencia libre.
    \item \href{https://es.wikipedia.org/wiki/Apache_Cassandra}{Cassandra}: base de datos NoSQL distribuida y basada en el modelo clave-valor, desarrollada por Apache y de licencia libre.
    \item \href{https://es.wikipedia.org/wiki/Elasticsearch}{Elasticsearch}: base de datos documental que cuenta con un servidor de búsqueda de texto completo.
\end{itemize}

Existen otros SGBD (tanto relacionales como no), pero el listado muestra las más conocidas y utilizadas a día de hoy. La elección del SGBD que vayamos a utilizar en nuestro proyecto debería ir acompañado de un análisis profundo de las características de cada uno de ellos, así como de las necesidades que requerimos.


\chapter{MySQL como Sistema Gestor de Base de Datos}
\begin{wrapfigure}{r}{0.25\linewidth}
    \centering
    \vspace{-20pt}
    \includegraphics[width=\linewidth]{MySQL_logo.png}
    \vspace{-60pt}
\end{wrapfigure}
El SGBD que usaremos durante esta asignatura es MySQL.


\section{Introducción}
MySQL es un sistema de gestión de bases de datos relacional desarrollado actualmente por Oracle Corporation, conocida empresa que también tiene su sistema SGBD Oracle privativo. MySQL cuenta con una \textbf{licencia dual}: Licencia Pública General (\hyperlink{licencias_libres}{GPL}) y licencia comercial, por lo que en su página web podremos encontrar ambas versiones (la primera de código abierto y gratuita, y la segunda con opción de pago, con servicios extra  y soporte).

Actualmente MySQL está considerada como la base de datos relacional de código abierto más popular y se puede instalar en los tres sistemas operativos más conocidos actualmente.


\subsection{Un poco de historia}
MySQL fue inicialmente desarrollado por MySQL AB (empresa fundada por David Axmark, Allan Larsson y Michael Widenius). MySQL AB fue adquirida por Sun Microsystems en 2008, y ésta a su vez fue comprada por Oracle Corporation en 2010.

Es cierto que aunque en sus primeras versiones carecía de características como la integridad referencial y transacciones (debido al motor MyISAM utilizado en la creación de tablas), que son características muy importantes en un SGBD (y que \href{https://es.wikipedia.org/wiki/PostgreSQL}{PostgreSQL} sí tenía), no impidió que cogiera fama en los denominados entornos LAMP (Linux + Apache + MySQL + PHP).

Poco antes de la compra de Oracle, desde la comunidad libre se realizó un fork (una copia completa) del código fuente de MySQL que dió origen a \textbf{MariaDB}. Desde ese momento, ambos SGBD han tenido vidas paralelas, pero el origen es el mismo.

Muchas distribuciones GNU/Linux contaban con MySQL como sistema SGBD para poder ser instalado, pero a medida que el desarrollo de MariaDB fue ganando adeptos muchas distribuciones realizaron el cambio, por lo que en ciertas distribuciones no es posible instalar MySQL desde los \hyperlink{repositorio_de_software}{repositorios oficiales}. De hecho, algunas distribuciones mantienen el \hyperlink{paquete_de_software}{paquete} MySQL pero siendo un alias para que se instale MariaDB.

Desde la compañía \href{https://www.percona.com/}{Percona} también crearon un fork de MySQL en el que añaden mejoras creadas por ellos y también venden soporte para el mismo.

Como veremos a continuación, el no poder realizar la instalación desde los repositorios oficiales no nos impedirá tener MySQL instalado en nuestro sistema.


\subsection{Versiones de MySQL}
MySQL cuenta con distintas versiones de SGBDs que hay que conocer para saber qué versión se necesita en cada caso concreto. Nos vamos a centrar en las versiones \textbf{Community} (las de licenciamiento libre), pero estas versiones también cuentan con su versión con licencia comercial.

\subsubsection{MySQL Community Server}
Es el SGBD que vamos a utilizar. Es la versión “clásica” de MySQL como SGBD, que permite crear bases de datos, introducir datos, manipularlos, … Esta versión cuenta con la opción de crear un sistema replicado “Primario → Réplica” o “Primario ←→ Primario” como veremos a lo largo del curso.

\subsubsection{MySQL Cluster}
Originalmente MySQL no soportaba crear clusters de servidores, sólo el sistema de replicación que soporta la versión “Community Server”, por lo que surgió la necesidad de poder crear un sistema clusterizado de 3 nodos o más que se gestionasen entre ellos, mantuvieran la información replicada… Eso se pudo realizar gracias a la librería Galera, que sirve para sincronizar la replicación de múltiples padres.

Hay que recordar que \textbf{MySQL Server es distinto a MySQL Cluster}, aunque desde un punto de vista de usuario que no entiende pueda parecer lo mismo.

\subsubsection{MySQL Router}
MySQL Router provee un enrutado transparente entre la aplicación de un usuario y cualquier servidor de MySQL. Puede sernos útil en sistemas de alta disponibilidad o de escalado para enrutar el tráfico al backend que más nos interese.

\subsubsection{MySQL Workbench}
Es un interfaz gráfico que nos proporciona herramientas para comprobar el estado de MySQL en el sistema remoto que tengamos que administrar. Existen versiones para distintos sistemas operativos y podremos instalarlo para conectarnos a servidores MySQL Remotos.

\section{Características de MySQL Community Server}
MySQL cuenta con una serie de características que hace que sea utilizado como SGBD de manera generalizada actualmente. Entre las características a destacar:

\begin{itemize}
    \item \textbf{Facilidad de uso}: Es un SGBD sencillo de utilizar en comparación con otras alternativas libres o privativas (PostgreSQL u Oracle respectivamente)
    \item \textbf{Soporte de motores de almacenamiento}: Hasta la versión 5.5 se hacía uso del motor MyISAM que no tenía integridad referencial, pero eso se cambió por el uso del motor \textbf{InnoDB} que es el utilizado actualmente. \href{https://dev.mysql.com/doc/refman/8.0/en/storage-engines.html}{Soporta varios motores}, entre los que podemos destacar:

    \begin{itemize}
        \item \textbf{InnoDB}: el utilizado por defecto actualmente. Es ACID compliant, seguro en transacciones, posibilidad para realizar commit y rollback.
        \item \textbf{MyISAM}: debería usarse sólo para tablas de lectura, ya que no soporta transacciones, pero es muy rápido.
        \item \textbf{Memoria}: se guarda toda la información en RAM, por lo que no sirve para persistencia de datos, pero hace que la información sea más rápida al acceder a ella
        \item \textbf{CSV}: las tablas realmente son ficheros de texto en formato CSV. No soporta indexado.
    \end{itemize}

    \item \textbf{Diseño multi-thread}: por lo que permite hacer uso de múltiples hilos de CPU en caso de que estén disponibles.
    \item \textbf{Replicación}: Permite crear entornos de replicación Primario → Réplica y Primario ←→ Primario.
    \item \textbf{Multiplataforma}: Funciona en distintas plataformas (distintas versiones de GNU/Linux, MacOS, Windows, FreeBSD, …).
    \item \textbf{Software Libre}: Tiene \hyperlink{licencias_libres}{licencia libre} lo que hace que podamos ver cómo funciona, y realizar modificaciones al código. Con ello se ha conseguido:
    \begin{itemize}
        \item \textbf{Mucho soporte de la comunidad}: Existen muchas herramientas realizadas por la comunidad que facilitan el uso y/o la administración de servidores MySQL.
    \end{itemize}
\end{itemize}

\section{Instalación de MySQL Community Server}
Como ya se ha mencionado antes, en algunas distribuciones MySQL ha sido sustituido por MariaDB (como en el caso de Debian), mientras que en otras se puede realizar la instalación de cualquiera de las dos (el caso de \hyperlink{ubuntu}{Ubuntu}).

Aunque haremos uso de la distribución Ubuntu, también se va a explicar brevemente cómo se haría la instalación en sistemas donde no podemos contar con el paquete en el repositorio oficial.

\subsection{Sin paquete en el repositorio oficial}
En caso de que nuestra distribución no cuente con el paquete en los repositorios oficiales, la instalación no será tan directa, pero eso no significa que sea difícil. La versión Community Server la podremos encontrar en su \href{https://dev.mysql.com/downloads/mysql/}{web de descarga}, y desde aquí podremos descargarnos la versión que necesitemos para el sistema operativo que queramos.

En el caso de que queramos instalarlo en una distribución de GNU/Linux como Debian, Red Hat o Suse podremos hacer uso de los repositorios oficiales de MySQL para realizar la instalación. En el caso de Debian, sería:

\begin{itemize}
    \item Descargar el paquete para poder configurar el repositorio oficial de MySQL para Debian/Ubuntu.
    \item Instalar el paquete:
\begin{mycode}{Instalar paquete MySQL descargado de la web oficial}{console}{}
ruben@server1:~$ sudo dpkg -i mysql-apt-config_0.8.15-1_all.deb
\end{mycode}
    \item Elegir en el menú que nos aparecerá:
    \begin{itemize}
        \item En qué distribución estamos (ya que el mismo paquete sirve para Debian y Ubuntu).
        \begin{center}
            \includegraphics[width=0.6\linewidth]{install_1.png}
        \end{center}

        \item Qué versión vas a querer instalar (dependiendo de la distribución y la versión en la que nos encontremos nos dejará unas versiones u otras).
        \begin{center}
            \includegraphics[width=0.6\linewidth]{install_2.png}
        \end{center}
    \end{itemize}

    \item Instalar mysql-server (tal como veremos a continuación en Ubuntu).

\end{itemize}


\subsection{En Ubuntu 20.04}
La versión \hyperlink{lts}{LTS} de Ubuntu 20.04 cuenta con la versión \textbf{8.0 de MySQL} (concretamente la \textbf{8.0.21} en el momento en el que es creado este documento).

Debido a que contamos con esta versión, que es la última versión de MySQL podremos realizar la instalación de la siguiente manera:

\begin{mycode}{Instalar paquete MySQL del repositorio de la distribución}{console}{}
ruben@server1:~$ sudo apt install mysql-server-8.0
\end{mycode}



\chapter{Administración básica de MySQL}
Una vez tenemos instalado nuestro SGBD tenemos que aprender los conceptos básicos para poder conectarnos a él, poder configurarlo y llegar a administrarlo.

\section{Antes de empezar}
MySQL, al igual que otros SGBD y servidores en general, y más cuando hablamos de Software Libre, cuenta con una documentación online realizada por los creadores del software con la que nos tenemos que familiarizar.

El \href{https://dev.mysql.com/doc/refman/8.0/en/}{manual de referencia de MySQL} cuenta con mucha información acerca del servicio, de la configuración y administración, pero también de cómo utilizar el lenguaje SQL. Por lo tanto, es obligatorio tener soltura buscando información en él.


\section{Arquitectura Cliente → Servidor en MySQL}
MySQL funciona en “modo servidor” esperando a las conexiones de un cliente, lo que comúnmente se denomina “arquitectura Cliente → Servidor”.

\begin{center}
    \vspace{-10pt}
    \includegraphics[width=0.6\linewidth]{cliente_servidor.png}
\end{center}

El cliente que efectúa la conexión puede encontrarse en la misma máquina donde está situado el servidor (conexión local) o desde una máquina externa (conexión remota).


\subsection{Conexión local (Socket)}
En entornos UNIX existe la posibilidad de realizar la conexión a ciertos servidores que están en la misma máquina desde la que se origina la conexión, mediante lo que se denomina un \textbf{Unix domain Socket}.

\textbf{Los sockets} en entornos GNU/Linux se pueden ver como un fichero, y \textbf{son un medio de comunicación entre procesos que se ejecutan en la misma máquina}.

La configuración estándar de MySQL arranca creando un fichero Socket en la siguiente ruta por defecto \configfile{/var/run/mysqld/mysqld.sock}, por lo que la posibilidad de realizar una conexión local mediante dicho socket es posible.

De hecho, nada más realizar la instalación de MySQL es la única manera de poder realizar la conexión y sólo será posible desde el usuario root:

\begin{center}
    \vspace{-15pt}
    \includegraphics[width=0.8\linewidth]{console_1.png}
    \vspace{-20pt}
\end{center}

Como se puede ver, en la imagen, los pasos para poder realizar la conexión han sido:
\begin{enumerate}
    \item Convertirnos en root
    \item Ejecutar el comando \commandbox{mysql}.
\end{enumerate}

Este comando es el \textbf{Cliente} MySQL que realizará la conexión contra el Servidor MySQL. Debido a que no se le ha pasado ningún parámetro al comando, éste realizará un primer intento de conexión a la ruta del socket estándar (indicada anteriormente).

Una vez realizada la conexión veremos que nos aparece un \textit{prompt}  \inlineconsole{mysql>} que indica que la conexión se ha realizado correctamente y estamos en el CLI (\textit{Command Line Interface}, Interfaz de Línea de Comandos) donde podremos ejecutar órdenes de configuración, administración o peticiones a las bases de datos.

\subsection{Conexión por red (local o remota)}
En la configuración inicial de MySQL también aparece la opción de poder realizar una conexión mediante el protocolo de red \textbf{TCP}.

\begin{mycode}{Ver puertos de MySQL}{console}{\scriptsize}
root@server1:~# ss -punta | grep -i mysql
tcp   LISTEN 0      151      127.0.0.1:3306    0.0.0.0:*      users:(("mysqld",pid=765,fd=34))
tcp   LISTEN 0      70               *:33060         *:*      users:(("mysqld",pid=765,fd=31))
\end{mycode}

Los puertos de escucha son:
\begin{itemize}
    \item \textbf{3306}: Puerto que escucha únicamente en la IP 127.0.0.1
    \item \textbf{33060}: Nuevo protocolo X (desde la versión 5.7.12) que escucha en todas las IPs del sistema.
\end{itemize}

Para poder realizar conexiones a través de estos puertos los usuarios con los que intentemos conectarnos deberán poder aceptar dicha conexión. Más adelante veremos cómo realizar estas modificaciones.

Para poder realizar esta conexión también haremos uso del comando  \commandbox{mysql}. pero esta vez sí le tendremos que pasar parámetros de conexión. Un ejemplo de cómo conectarnos a un servidor por conexión de red es:

\begin{mycode}{Conexión por red a MySQL}{console}{}
ruben@server1:~$ mysql -u usuario -h 192.168.1.100 -p
\end{mycode}

Podemos ver que se han pasado 3 parámetros y a continuación el valor que se le pasa a cada parámetro en el comando \commandbox{mysql}. Los parámetros son:

\begin{itemize}
    \item[\textbf{-u}] o “\textbf{\-/\-/ user}”, es el usuario con el que vamos a realizar la conexión. Si no se usa éste parámetro, por defecto se le pasará el usuario con el que estamos logueados en el sistema
    \item[\textbf{-h}] o “\textbf{\-/\-/ host}”, es el servidor al que queremos conectarnos mediante conexión por red. Si no se pone este parámetro la conexión se intentará a 127.0.0.1
    \item[\textbf{-p}] o “\textbf{\-/\-/ password}”, para que nos pregunte por la contraseña de conexión del usuario. Si no se pasa este parámetro se entiende que no se va a necesitar contraseña.
\end{itemize}

\section{Arranque, parada y estado del Servidor}
Una vez instalado MySQL tenemos que conocer cuál es su estado y conocer los procedimientos de arranque y parada del servicio.

\subsection{Comprobar estado del servidor}
En la instalación de MySQL se ha instalado automáticamente un servicio en \hyperlink{systemd}{Systemd} que nos permitirá conocer el estado de MySQL, si está arrancado o no.

Para ello deberemos ejecutar el siguiente comando:

\begin{mycode}{Estado del servidor MySQL}{console}{}
ruben@server1:~$ sudo systemctl status mysql
\end{mycode}

Y tras realizar la ejecución del comando, en caso de que el servicio esté arrancado veremos:

%TODO: cambiar captura por texto

\begin{center}
    \vspace{-15pt}
    \includegraphics[width=0.8\linewidth]{mysql_status.png}
    \vspace{-10pt}
\end{center}

\subsection{Arranque y parada del servidor}
En caso de que queramos parar el servidor, tendremos que hacer uso de Systemd:

\begin{mycode}{Parar el servidor MySQL}{console}{}
ruben@server1:~$ sudo systemctl stop mysql
\end{mycode}

Y para arrancarlo de nuevo:

\begin{mycode}{Arrancar el servidor MySQL}{console}{}
ruben@server1:~$ sudo systemctl start mysql
\end{mycode}


\section{Primeros pasos}
Como suele ser habitual cuando instalamos un servidor, viene con una configuración genérica que dista mucho de ser la ideal en un entorno productivo, y es por ello que tenemos que conocer cómo realizar modificaciones en la configuración para obtener mejores resultados.

Para poder administrar y configurar de manera correcta MySQL tendremos que conocer, al menos, lo siguiente:

\begin{itemize}
    \item Especificaciones hardware donde está el servidor:
    \begin{itemize}
        \item Cantidad de memoria RAM
        \item Espacio en disco duro
        \item Velocidad de escritura/lectura a disco duro
    \end{itemize}
    \item Tipo de aplicación que va a utilizar MySQL
    \item Conexiones esperadas
    \item Cantidad de usuarios que se van a conectar
    \item Origen de las conexiones
    \item …
\end{itemize}

Con esta información podremos realizar un primer análisis para intentar prever si el servidor donde está el servicio MySQL corriendo es suficiente o no. Si la instalación nos corresponde a nosotros, tendremos que conocer parte de las preguntas planteadas anteriormente para realizar la instalación en un servidor que vaya a poder adecuarse a las exigencias pedidas.


\hypertarget{securizar_configuracion_inicial}{}
\subsection{Securizar configuración inicial}
Dependiendo del método elegido para instalar MySQL la configuración inicial puede venir con usuarios o bases de datos de prueba que no nos interesan y que se pueden borrar. Para poder securizarlo tenemos el siguiente comando:

\begin{mycode}{Securizar la instalación}{console}{}
root@server1:~# mysql_secure_installation
\end{mycode}

Este script nos guiará con una serie de preguntas para securizar el servidor, que es muy utilizado en versiones anteriores, pero que no está de más ver las preguntas que nos realiza:

\begin{itemize}
    \item “\textbf{Would you like to setup VALIDATE PASSWORD component?}”: Habilita el componente de validación de contraseñas, que sirve para habilitar test de fuerza de las contraseñas, y en caso de no ser lo suficientemente seguras, no se permite crear el usuario con esa contraseña.

    \warnbox{En versiones anteriores era un PLUGIN}

    Si lo habilitamos, no preguntará qué tipo de política queremos activar sobre las contraseñas:
        \begin{itemize}
            \item \textbf{LOW}: contraseñas de longitud mínima 8
            \item \textbf{MEDIUM}: como las LOW pero con números, caracteres especiales y mayúsculas y minúsculas.
            \item \textbf{STRONG}: como las MEDIUM pero que no se encuentren en un
        \end{itemize} diccionario
    \item Nos pedirá la \textbf{contraseña del administrador “root”} de MySQL.  En la instalación de Ubuntu el usuario root se conecta mediante socket, por lo que este paso no cambiará nada.
    \item “\textbf{Remove anonymous users?}”: En algunas distribuciones  se crean unos usuarios anónimos, que deberían ser borrados.
    \item “\textbf{Disallow root login remotely?}”: De nuevo, en Ubuntu el usuario root sólo se puede conectar en local mediante el socket, pero en otras distribuciones es posible que root pueda conectarse por TCP desde otros servidores y/o equipos. Lo recomendable suele ser que para root no se permitan conexiones remotas.

    \item “\textbf{Remove test database and access to it?}”: MySQL suele venir con una base de datos de prueba llamada “test”. Se puede borrar.

    \item “\textbf{Reload privilege tables now?}”: Recargar los permisos de los privilegios, ya que hemos realizado cambios en las contraseñas.
\end{itemize}


\section{Ficheros de configuración}
Como es habitual en GNU/Linux, los ficheros de configuración de los servicios están situados en el path \configdir{\etc} en este caso concreto dentro de la ruta \configdir{/etc/mysql} MySQL puede leer distintos ficheros de configuración, por lo que dependiendo de la distribución puede variar cuál tengamos, pero el orden suele ser:

\begin{itemize}
    \item \configfile{/etc/my.cnf}: Es el primer fichero de configuración que se busca (en Ubuntu no lo tendremos)
    \item \configfile{/etc/mysql/my.cnf} : Fichero principal de configuración. En Ubuntu es un enlace simbólico a   \configfile{/etc/alternatives/my.cnf} que a su vez es un enlace simbólico a \configfile{/etc/mysql/mysql.cnf}. Esto es debido a que en versiones antiguas esta última ruta era la oficial.
\end{itemize}

Si vemos este fichero de configuración veremos que tiene una directiva “\textbf{!includedir}”, esto significa que se van a incluir todos los ficheros con extensión “\textbf{cnf}” de esos directorios.

Estos ficheros de configuración tienen el formato conocido como “INI” y suele ser de este aspecto:

\begin{mycode}{Ejemplo de fichero de configuración por secciones}{ini}{}
[section]
option1    = value

[section2]
option2     = value
\end{mycode}

Debido a que durante la instalación de MySQL se han instalado otras herramientas, la sección determinará para qué servicio o aplicación será esa parte de la configuración:

\begin{itemize}
    \item \textbf{mysqld}:  servidor MySQL (\textbf{mysql d}aemon)
    \item \textbf{mysql}: cliente de consola para realizar la conexión
    \item \textbf{mysqldump}: programa para realizar backups de las bases de datos.
\end{itemize}

Cuando realicemos modificaciones en la configuración de la configuración, si es para el servidor de MySQL tendremos que realizar un reinicio del servicio para que estas modificaciones sean tenidas en cuenta.

\subsection{Analizando la configuración inicial}
Tal como hemos comentado previamente, los ficheros de configuración en \configdir{/etc/mysql} pueden estar en distintos ficheros, por lo que es recomendable echar un ojo a los ficheros que tenemos tras realizar la instalación. Vamos a analizar parte del fichero: \configfile{/etc/mysql/mysql.conf.d/mysqld.cnf}:


\begin{mycode}{Ejemplo de fichero de configuración de MySQL}{ini}{}
#
# The MySQL database server configuration file.
# ...
[mysqld]
#
# * Basic Settings
#
user            = mysql
# pid-file      = /var/run/mysqld/mysqld.pid
# socket        = /var/run/mysqld/mysqld.sock
# port          = 3306
# datadir       = /var/lib/mysql
bind-address      = 127.0.0.1

#
# * Fine Tuning
#
key_buffer_size         = 16M
# max_connections        = 151

#
# * Logging and Replication
#
# Both location gets rotated by the cronjob.
#
# Log all queries
# Be aware that this log type is a performance killer.
# general_log_file        = /var/log/mysql/query.log
# general_log             = 1
#
# Error log - should be very few entries.
#
log_error = /var/log/mysql/error.log
#
# Here you can see queries with especially long duration
# slow_query_log                = 1
# slow_query_log_file   = /var/log/mysql/mysql-slow.log
# long_query_time = 2
# log-queries-not-using-indexes
\end{mycode}

Como se puede comprobar, en el fichero se pueden comprobar distintos tipos de filas, y el usar un editor que realice resaltado de sintaxis nos puede ayudar a diferenciar las líneas y lo que son. Vamos a realizar una pequeña explicación de varias líneas:

\begin{itemize}
    \item Líneas que empiezan por “\textbf{\#}”:  Al igual que sucede con otros ficheros de configuración, en este caso las líneas que empiezan por almohadilla, o “\#”, son comentarios. Estas líneas son ignoradas y nos pueden ayudar a comprender la estructura del fichero o podremos poner comentarios para explicar para qué sirve una directiva de configuración.
    \item \textbf{[mysqld]}: Es el comienzo de la sección, y como se ha dicho previamente, esta sección será la que se utilice al arrancar MySQL. Por lo tanto, toda directiva de configuración dentro de esta sección servirá para modificar el comportamiento por defecto del servidor.
    \item \textbf{user}: indica al servidor MySQL con qué usuario arrancará el servidor
    \item \textbf{bind-address}: dirección en la que escuchará el servidor MySQL al arrancar
    \item \textbf{log\_error}: fichero donde aparecerá lo acontecido durante el arranque del servicio y en caso de haber errores nos indicará parte de la razón.
\end{itemize}

Otras variables que aparecen comentadas en la configuración inicial y por tanto el valor que tiene esa opción de configuración no tiene por qué ser la que se esté utilizando actualmente:

\begin{itemize}
    \item \textbf{pid-file}: fichero donde se escribirá el PID (\textit{Process IDentificator}) durante el arranque.
    \item \textbf{socket}: fichero donde está el socket.
    \item \textbf{port}: puerto en el que escucha MySQL.
    \item \textbf{datadir}: lugar donde se almacena todos los datos de las bases de datos.
    \item \textbf{max\_connections}: número máximo de conexiones que aceptará MySQL
    \item \textbf{general\_log\_file}: lugar donde se escribe el log general en caso de estar activo.
    \item \textbf{general\_log}: activar, o no, el log general. Como se puede comprobar en un comentario previo, puede suponer un problema en el rendimiento del servidor.
    \item \textbf{slow\_query\_log}: log de queries lentas.
    \item \textbf{long\_query\_time}: el tiempo mínimo para que una slow query se loguee.
    \item \textbf{log-queries-not-using-indexes}: loguear las queries que no usan índices.
\end{itemize}

Como se puede ver en estas variables de configuración, y en las anteriores, el nombre de las mismas suele ser bastante auto-explicativo, por lo que nos podemos hacer una pequeña idea de lo que pueden hacer leyendo el nombre. Eso no quita para que en caso de duda, debemos consultar el \href{https://dev.mysql.com/doc/refman/8.0/en/server-option-variable-reference.html}{listado completo de variables} que puede llegar a tener MySQL.

Como se ha comentado previamente, en caso de realizar una modificación en el fichero de configuración, tendremos que realizar un reinicio del servicio como veremos posteriormente.

\subsection{Validando la configuración}
Las variables de configuración que hemos visto hasta ahora cuentan con dos apartados:

\begin{itemize}
    \item \textbf{Nombre de la variable}: puede ser una única palabra (\textbf{port}, \textbf{socket}) o varias seguidas de guión bajo (\textbf{bind\_address}, \textbf{slow\_query\_log}).
    \item \textbf{Valor de la variable}: Es el valor que aparece a la derecha del igual (“=”) y vemos que pueden tener distintos valores: mysql, 127.0.0.1, 16M , …
\end{itemize}

Los nombres de las variables es algo que no nos podemos inventar, y es por ello por lo que deben estar bien escritas en el fichero de configuración. En caso de escribir una variable que no exista, el servidor no arrancará si hacemos un reinicio del mismo. Ejemplo:

\begin{mycode}{Ejemplo de log de error}{ini}{\footnotesize}
2020-08-01T11:35:50.488392Z 0 [ERROR] [MY-000067] [Server] unknown variable 'mal=32M'
\end{mycode}

Como se puede ver en esta línea de log, hay un error al haber escrito una variable desconocida (en este caso el nombre de la variable es “mal”). Esto hace que el servidor no arranque y por tanto no se pueda acceder a él y haya una pérdida de servicio. Esto no debe suceder en un servidor en producción.

Para evitar este problema, antes de realizar cualquier reinicio del servidor, debemos asegurarnos que el fichero de configuración no contiene variables desconocidas:

\begin{mycode}{Confirmar estado de la configuración}{console}{\footnotesize}
root@ubuntu:/etc/mysql/mysql.conf.d# mysqld --validate-config

2020-08-01T12:02:41.763658Z 0 [ERROR] [MY-000067] [Server] unknown variable 'mal=32M'
2020-08-01T12:02:41.763689Z 0 [ERROR] [MY-010119] [Server] Aborting
\end{mycode}


Esta opción nos puede ser útil si realizamos una actualización de MySQL y en la nueva versión ya no existen variables de versiones anteriores (es raro, pero puede haber opciones obsoletas).

\errorbox{\textbf{Esta validación de configuración no hace una comprobación exhaustiva del valor adjudicado a la variable}}

Esta validación de configuración no hace una comprobación exhaustiva del valor adjudicado a la variable, por lo que en caso de que la variable sea correcta pero el valor adjudicado sea erróneo, al reiniciar el servidor tendremos que comprobar el log de errores para ver qué sucede. Por ejemplo, de tener lo siguiente en la configuración:

\begin{mycode}{Error puesto en la configuración}{ini}{}
bind-address            = 127.0.0.1z
\end{mycode}

Al intentar reiniciar, veremos el siguiente error en \configfile{/var/log/mysql/error.log}:

\begin{mycode}{Error en el log}{ini}{}
[ERROR] [MY-010255] [Server] Can't create IP socket: Invalid argument
\end{mycode}

En cambio, si otras variables tienen un valor incorrecto, el servidor arrancará, y el valor que cogerá la variable dependerá de cómo se parsea el fichero de configuración. Por ejemplo:

\begin{mycode}{Error en la configuración}{ini}{}
key_buffer_size            = 16Mz
max_connections            = -1
\end{mycode}

Para conocer qué valor pueden tener estas variables, lo mejor es ir a la documentación y mirar la variable que queremos modificar o agregar.  Por ejemplo, para \href{https://dev.mysql.com/doc/refman/8.0/en/server-system-variables.html#sysvar_slow_query_log}{slow\_query\_log} veremos que en la documentación tiene la siguiente tabla:


\begin{table}[H]
    \tablestyle
    \begin{tabular}{|p{0.3\linewidth}|p{0.4\linewidth}|}
        \theadstart
            \thead \centering \textbf{Referencia} &
            \thead \centering \textbf{Valor} \tabularnewline
        \tbody
            Command-Line Format & \texttt{\-/-slow-query-log[=\{OFF|ON\}]} \\
            System Variable & slow\_query\_log \\
            Scope & Global \\
            Dynamic & Yes \\
            SET\_VAR Hint Applies & No \\
            Type & Boolean \\
            Default Value & OFF \\
        \tend
    \end{tabular}
\end{table}

Esta tabla nos da mucha información acerca de la variable, ya sea para poder ver qué tipo de valor es (Boolean en este caso), su valor por defecto (OFF) y si podremos o no modificarla dinámicamente (Dynamic = Yes). El valor por defecto será el valor que obtendrá la variable si no aparece en el fichero de configuración con un valor puesto por nosotros.

Otro ejemplo, \href{https://dev.mysql.com/doc/refman/8.0/en/server-system-variables.html#sysvar_bind_address}{bind\_address}:

\begin{table}[H]
    \tablestyle
    \begin{tabular}{|p{0.3\linewidth}|p{0.4\linewidth}|}
        \theadstart
            \thead \centering \textbf{Referencia} &
            \thead \centering \textbf{Valor} \tabularnewline
        \tbody
            Command-Line Format & \texttt{\-/-sbind-addr=addr} \\
            System Variable & sbind\_address \\
            Scope & Global \\
            Dynamic & No \\
            SET\_VAR Hint Applies & No \\
            Type & String \\
            Default Value & * \\
        \tend
    \end{tabular}
\end{table}


\section{Variables de configuración en MySQL}
Tal como hemos visto, el listado completo de variables tiene cientos de posibles variables que podemos ver o modificar para ajustar el servidor a nuestros intereses. Las variables se deben separar en dos partes:

\begin{itemize}
    \item \textbf{System Var}: Variables que sirven para el arranque del servidor o para ajustar el comportamiento del mismo. Se pueden modificar.
    \item \textbf{Status Var}: Variables para comprobar el estado del servidor. Sólo las podremos leer.
\end{itemize}

Las variables que podremos modificar se pueden pasar por:

\begin{itemize}
    \item \textbf{Fichero de configuración}: la versión más cómoda, tal como hemos visto previamente. Hará que nuestro servidor siempre arranque con la misma configuración ya que los ficheros estarán escritos en el servidor.
    \item \textbf{Línea de comandos}: al arrancar mysqld, se le pueden pasar como parámetros estas variables con los valores que queramos. Se nos puede olvidar pasar algún parámetro.
\end{itemize}

Hay variables del sistema que si nos fijamos en la tabla no se puede pasar por fichero o por línea de comandos. Esto es debido a que son variables internas de cómo ha sido compilado MySQL o que tienen en cuenta las librerías del sistemas. Por ejemplo: \textbf{version}, \textbf{have\_ssl}.

Si nos fijamos en la columna “\textbf{Var Scope}” vemos que puede tener los valores:

\begin{itemize}
    \item \textbf{Global} : son variables que afectan a las nuevas conexiones que se realizan.
    \item \textbf{Session} : son variables que afectan a la sesión actual. Si intentamos leer una variable de sesión que no existe, nos mostrará el valor global.
    \item \textbf{Both} : son variables que existen en ambos estados, global y en sesión, y pueden diferir.
    \item \textbf{Varies} : Hay unas pocas variables que tienen esta opción (y también en la columna Dynamic) y nos indica que varía dependiendo de la versión de MySQL que estemos usando.
\end{itemize}

\subsection{Comprobando las variables de estado (STATUS)}
El \href{https://dev.mysql.com/doc/refman/8.0/en/server-status-variable-reference.html}{listado de variables} de estado nos muestra el nombre de las variables por las que podemos preguntar, el tipo de valor que pueden tener y si son globales o de sesión.

Para comprobar el estado de las variables globales del servidor:

\begin{mycode}{Ver variables de estado}{mysql}{}
mysql> SHOW GLOBAL STATUS;
\end{mycode}

Si nos interesa buscar por el nombre de alguna variable de la sesión y obtener su estado:

\begin{mycode}{Ver variables de sesión}{mysql}{}
mysql> SHOW SESSION STATUS LIKE '%slow%';
+-----------------------------+-------+
| Variable_name               | Value |
+-----------------------------+-------+
| Slow_launch_threads         | 0     |
| Slow_queries                | 0     |
+-----------------------------+-------+
2 rows in set (0.01 sec)
\end{mycode}

\subsection{Comprobando las variables del sistema (System)}
Hemos visto que en los ficheros de configuración no están todas las variables que hemos visto en la \href{https://dev.mysql.com/doc/refman/8.0/en/server-option-variable-reference.html}{documentación}, y no tendría mucho sentido tener que estar yendo a ella para mirar qué variables tenemos y sus posibles valores por defecto. Para ver las variables globales del sistema, \textbf{es obligatorio poner GLOBAL}:

\begin{mycode}{Ver variables globales}{mysql}{}
mysql> SHOW GLOBAL VARIABLES;
\end{mycode}

Si queremos buscar por una variable en concreto en la sesión, poner SESSION es opcional (en lugar de GLOBAL).

De no poner en qué ámbito queremos mirar las variables, se presupone que queremos ver el estado de la variable en la sesión actual.

Si queremos buscar una variable que contenga algo en el nombre podremos hacer uso de:

\begin{mycode}{Ver variables globales}{mysql}{}
mysql> SHOW VARIABLES like '%slow%';
+----------------------------+---------------------------------+
| Variable_name              | Value                           |
+----------------------------+---------------------------------+
| log_slow_admin_statements  | OFF                             |
| log_slow_extra             | OFF                             |
| log_slow_slave_statements  | OFF                             |
| slow_launch_time           | 2                               |
| slow_query_log             | OFF                             |
| slow_query_log_file        | /var/lib/mysql/ubuntu-slow.log  |
+----------------------------+---------------------------------+
6 rows in set (0.01 sec)
\end{mycode}

De esta manera buscamos las variables que nos puedan interesar y vemos el valor que tienen actualmente en la sesión, para así poder ver si nos interesa cambiarlo.

También podemos hacer uso desde la línea de comandos con el comando \commandbox{mysqladmin}, pero no tenemos tanta libertad como desde el CLI de MySQL :

\begin{mycode}{Ver variables desde la consola}{console}{}
root@server1:~# mysqladmin  variables
\end{mycode}

\subsection{Modificar configuración “en caliente”}
Debido a que un SGBD es un servicio crítico, no siempre podremos realizar una parada de servicio debido a un cambio de configuración. Esto afectaría a todas las conexiones que tiene establecido el servidor, y cualquier intento de consulta sería rechazado durante la parada y el arranque del mismo.

No sólo eso, ya que cuando un SGBD está en funcionamiento, guarda información en memoria RAM (a modo de caché para las peticiones más realizadas, traspasa parte de las tablas a memoria, … ) y en caso de realizar un reinicio, esa memoria se liberaría y por tanto al arrancar se debería volver a pedir los datos a disco duro, haciendo que los primeros instantes de servicio sea lento.

Por ello, \textbf{se pueden realizar modificaciones de la configuración sin parar el servicio}, lo que se suele denominar “hacer modificaciones en caliente”.

Bien es cierto que no todas las variables se pueden modificar de esta manera, ya que algunas son necesarias durante el arranque del servicio. Por ejemplo:

\begin{itemize}
    \item \textbf{port}: no podrá ser modificada “en caliente”, ya que el puerto debe de ser algo que se necesita durante el arranque.
    \item \textbf{bind\_address}: lo mismo que la anterior.
    \item \textbf{slow\_query\_log}:  si se puede modificar en caliente.
\end{itemize}

Para conocer si una directiva puede ser modificada en tiempo de ejecución podremos ir al \href{https://dev.mysql.com/doc/refman/8.0/en/server-option-variable-reference.html}{listado completo de variables} y comprobar la columna “Dynamic”, si aparece “Yes” es que se podrá modificar. Anteriormente hemos visto cómo la variable \href{https://dev.mysql.com/doc/refman/8.0/en/server-system-variables.html#sysvar_slow_query_log}{slow\_query\_log} tiene la opción “Dynamic” a “Yes”, por lo que se puede modificar el valor dinámicamente, y para cambiarlo haremos:

\begin{mycode}{Cambiar variable}{mysql}{}
mysql> SET slow_query_log = On;
ERROR 1229 (HY000): Variable 'slow_query_log' is a GLOBAL variable
and should be set with SET GLOBAL


mysql> SET GLOBAL slow_query_log = On;
Query OK, 0 rows affected (0.01 sec)

-- alternativa
mysql> SET @@GLOBAL.slow_query_log = On;
Query OK, 0 rows affected (0.01 sec)
\end{mycode}

Como se puede comprobar, se ha intentado modificar la variable sin poner “GLOBAL”, y debido a que “slow\_query\_log” es una variable global, nos ha dado un error. Por eso \textbf{es muy importante tener en cuenta qué tipo de variable y para qué ámbito queremos realizar la modificación.} También se puede ver que la modificación se puede realizar de dos maneras.

\warnbox{\textbf{Hay que tener en cuenta que la variable modificada en caliente no se guarda en la configuración y por tanto se perderá en el siguiente reinicio.}}

\subsubsection{Persistencia de las modificaciones}
MySQL permite que estas variables que podamos hacer que estas variables persistan tras el arranque haciendo:

\begin{mycode}{Cambiar variable de manera persistente}{mysql}{}
mysql> SET PERSIST slow_query_log  = ON;
\end{mycode}

Esto lo que hace es crear un fichero en \configfile{/var/lib/mysql/mysqld-auto.cnf} con formato \hyperlink{json}{JSON} con las variables que se ha dado la orden de persistir.

\errorbox{\textbf{No se aconseja utilizar este método. Mejor modificar la configuración.}}

Aunque resulte cómodo, se aconseja realizar la modificación de la variable en el fichero de configuración correspondiente para tener todo de manera más centralizada. Para deshacer esta persistencia:

\begin{mycode}{Eliminar las variables persistentes}{mysql}{}
mysql> RESET PERSIST;
Query OK, 0 rows affected (0.00 sec)
\end{mycode}

Y eliminará todas las entradas del fichero antes descrito: \configfile{/var/lib/mysql/mysqld-auto.cnf}.

\chapter{SQL básico}
\section{Introducción}
SQL (por sus siglas en inglés \textit{\textbf{S}tructured \textbf{Q}uery \textbf{L}anguage}) surgió como una evolución de un lenguaje previo llamado SEQUEL. SQL nació en IBM en 1977. Unos años más tarde fue considerado un estándar ANSI y al año siguiente (1987) un estándar ISO.

SQL tiene las siguientes características:

\begin{itemize}
    \item \textbf{Lenguaje de definición de datos (DDL)}: nos permite crear y/o manipular la estructura de la base de datos y las relaciones que en ellas deben existir.
    \item \textbf{Lenguaje de manipulación de datos (DML)}: este apartado se puede subdividir en las siguientes tareas:
    \begin{itemize}
        \item Consultar determinada información.
        \item Insertar nuevos datos.
        \item Modificar los datos existentes.
        \item Eliminar datos que ya no sean necesarios.
    \end{itemize}
    \item \textbf{Control de transacciones}: para definir cuándo se inicia, cuándo finaliza o si es necesario deshacer una transacción.
    \item \textbf{Control de datos}: permite asignar y revocar permisos a los usuarios, tanto de acceso a la información como de operaciones que pueden realizar sobre los mismos.
\end{itemize}

El lenguaje SQL puede ser utilizado:

\begin{itemize}
    \item De forma \textbf{interactiva}: en una consola o desde un CLI instalado en la propia máquina donde se encuentra el servidor u otra máquina remota.
    \item \textbf{Inmerso} dentro de un lenguaje de programación anfitrión, ejecutando consultas desde Java o PHP, por ejemplo.
\end{itemize}

Es un \textbf{lenguaje declarativo} ya que permite especificar la operación que se debe llevar a cabo (en forma de sentencias), pero no la forma en la que se llevará a cabo. Esa será la tarea del SGBD, ejecutar la tarea de la manera más adecuada para obtener los datos.

Los SGBD implementan (de manera parcial o total) el estándar SQL y sobre él añaden funcionalidades propias e incluso lenguajes de programación propios derivados de SQL (PL/SQL en Oracle, PL/pgSQL en PostgreSQL. Por lo tanto, \textbf{SQL no es un lenguaje de programación, pero hay SGBDs que han creado dicha funcionalidad}.

Debido a que SQL es un estándar, las funciones principales deberían funcionar en cualquier SGBD que haga uso del estándar, aunque es cierto que algunos SGBD amplían SQL con funciones o procedimientos propios que otros SGBD no tienen porqué tener. Esas funciones o procedimientos extra a veces se incorporan al estándar un tiempo después.

Dentro del lenguaje SQL podemos separar las consultas o acciones teniendo en cuenta qué realizamos con ellos.


\section{Lenguaje de definición de datos: DDL}
El DDL (Data Definition Language) de SQL proporciona comandos para la definición de esquemas de relación, borrado de relaciones y modificaciones de los esquemas de relación. Existen tres operaciones básicas: \textbf{CREATE}, \textbf{ALTER} y \textbf{DROP}.

\subsection{Gestión de bases de datos}
La función de un SGBD es la de proporcionar la capacidad de tener distintas bases de datos en el sistema, es por ello que tenemos que aprender a gestionar las bases de datos que tenemos, o en un momento dado crear bases de datos.


\begin{mycode}{Crear una base de datos}{mysql}{}
mysql> CREATE DATABASE prueba;
\end{mycode}




\begin{mycode}{Mostrar las bases de datos existentes}{mysql}{}
mysql> SHOW DATABASES;
+-----------------------------+
| Database                    |
+-----------------------------+
| information_schema          |
| mysql                       |
| performance_schema          |
| prueba                      |
| sys                         |
+-----------------------------+
5 rows in set (0.00 sec)
\end{mycode}


Para poder entrar en una base de datos y poder visualizar, modificar o usar las tablas y datos que hay en ella:

\begin{mycode}{”Entrar” en una base de datos}{mysql}{}
mysql> USE prueba;
Database changed
\end{mycode}

\begin{mycode}{Borrar una base de datos}{mysql}{}
mysql> DROP DATABASE prueba;
\end{mycode}


Si queremos crear una tabla alumnos con un modelo de datos propio:
\subsection{Gestión de tablas}
La gestión de tablas se realiza cuando estamos dentro de una base de datos, por lo que deberemos asegurarnos que hemos entrado dentro de una de ellas antes de realizar ninguna gestión sobre ellas.



\begin{mycode}{Crear distintas tablas}{mysql}{}
CREATE TABLE alumnos (
    dni      varchar(9) not null primary key,
    nombre   varchar(20),
    apellido varchar (20),
    telefono integer
);

CREATE TABLE asignaturas (
    codigo integer not null primary key,
    nombre varchar(50)
);

CREATE TABLE matriculacion_alumno (
codigo_asignatura integer,
dni_alumno varchar(9),
nota float,
fecha_matriculacion date,

PRIMARY KEY(codigo_asignatura, dni_alumno),
FOREIGN KEY (codigo_asignatura) REFERENCES asignaturas(codigo),
FOREIGN KEY (dni_alumno) REFERENCES alumnos(dni) ON DELETE CASCADE
);
\end{mycode}

Si queremos modificar el modelo de la tabla creada previamente

\begin{mycode}{Modificar una tabla, añadiendo una columna}{mysql}{}
mysql> ALTER TABLE alumnos ADD nacimiento date;
\end{mycode}


\begin{mycode}{Eliminar una tabla}{mysql}{}
mysql> DROP TABLE alumnos;
\end{mycode}

TRUNCATE es una función especial que vacía de contenido una tabla. Realmente lo que hace es borrar la tabla y volverla a crear, de ahí que sea considerada una función dentro del DDL.

\begin{mycode}{Truncar una tabla}{mysql}{}
mysql> TRUNCATE TABLE alumnos;
\end{mycode}

Para poder gestionar una tabla debemos saber cómo es y cómo está creada, ya que dependiendo de ello podremos realizar modificaciones sobre la misma.

Para ver las columnas que tiene una tabla podemos hacerlo de dos maneras:

\begin{mycode}{Ver columnas de una tabla}{mysql}{}
mysql> SHOW COLUMNS FROM alumnos;
mysql> DESCRIBE alumnos;
\end{mycode}

Podemos obtener más datos, como los privilegios que tenemos con el usuario que nos hemos conectado sobre cada columna haciendo:

\begin{mycode}{Ver permisos sobre columnas}{mysql}{}
mysql> SHOW FULL COLUMNS FROM alumnos;
\end{mycode}

Y si queremos ver cómo se ha creado la tabla:

\begin{mycode}{Ver cómo se ha creado una tabla}{mysql}{}
mysql> SHOW CREATE TABLE alumnos;
\end{mycode}


\section{Lenguaje de manipulación de datos: DML}
El DML (Data Manipulation Language) nos permite consultar, manipular, insertar o eliminar los datos.

\subsection{Realizar consultas}
A la hora de realizar consultas, podemos crear distintas y de distinto tipo.

\begin{mycode}{Consultar todos los registros de una tabla}{mysql}{}
mysql> SELECT * FROM alumnos;
\end{mycode}


\begin{mycode}{Consultar ciertos campos de una tabla}{mysql}{}
mysql> SELECT dni, nombre, nacimiento FROM alumnos;
\end{mycode}

También podemos realizar consultas condicionales:

\begin{mycode}{Realizar consulta condicional con una fecha}{mysql}{}
mysql> SELECT dni, nombre, nacimiento
            FROM alumnos
            WHERE nacimiento > '1982-01-01';
\end{mycode}


\begin{mycode}{Realizar consulta condicional y ordenada}{mysql}{}
mysql> SELECT dni, nombre, nacimiento
            FROM alumnos
            WHERE nacimiento > '1970-01-01'
            ORDER BY dni ASC;
\end{mycode}


La complejidad de las consultas dependen de nuestro modelo de datos así como de los datos que queremos obtener:

\begin{mycode}{Consulta relacionando varias tablas}{mysql}{{\small }}
mysql> SELECT a.dni, a.nombre, a.apellido, asig.nombre, ma.nota
            FROM alumnos as a, asignaturas as asig, matriculacion_alumno as ma
            WHERE a.dni = ma.dni_alumno
                AND asig.codigo = ma.codigo_asignatura
                AND ma.nota < 5
            ORDER BY a.dni ;
\end{mycode}


\subsection{Inserción y modificación de datos}
No sólo podemos realizar consultas de obtención de datos, sino que también podremos insertarlos, modificarlos o borrarlos.

\begin{mycode}{Insertar datos en una tabla}{mysql}{\scriptsize}
mysql> INSERT INTO alumnos VALUES ('12345678Z', 'Alumno', 'Uno', '555123456','1980-01-01');
\end{mycode}

En caso de que sólo queramos insertar parte de los datos, podremos realizar:

\begin{mycode}{Insertar sólo datos obligatorios en una tabla}{mysql}{}
mysql> INSERT INTO alumnos(dni,nombre) VALUES ('87654321A', 'Alumno2');
\end{mycode}

A la hora de actualizar datos, deberemos elegir qué campos queremos elegir

\begin{mycode}{Actualizar ciertos campos en una tabla}{mysql}{\small}
mysql> UPDATE alumnos SET nacimiento = '1984-01-01' WHERE dni = '87654321A';
\end{mycode}

Y a la hora de eliminar datos, podremos hacerlo de manera condicional.

\begin{mycode}{Eliminar ciertos registros de una tabla}{mysql}{}
mysql> DELETE FROM alumnos where dni = '87654321A';
\end{mycode}

\section{Control de transacciones}
Como ya se ha visto previamente, los SGBDs deben de seguir el modelo ACID de transacciones para asegurar que los datos mantienen la integridad de los datos y el aislamiento a la hora de realizar transacciones sobre los mismos datos.

Por ello, SQL permite realizar inicios de transacciones (\textit{\textbf{BEGIN}}) para posteriormente aplicar todos los cambios que se han realizado (\textit{\textbf{COMMIT}}) o cancelarlos (\textit{\textbf{ROLLBACK}}).


\warnbox{MySQL utiliza el método \textbf{autocommit} por defecto}


\subsubsection*{Empezar una transacción}
Nos sirve a la hora de realizar grandes modificaciones en la base de datos. Se puede realizar de las dos maneras siguientes:

\begin{mycode}{Hacer una transacción (se puede hacer de 2 maneras)}{mysql}{}
mysql> BEGIN;
-- alternativa:
mysql> START TRANSACTION;
\end{mycode}

A partir de aquí cualquier acción que se realice no será aplicada (aunque sí lo podremos ver en la sesión actual) hasta que no se termine la transacción.

\subsubsection*{Aplicar y terminar la transacción}
Para aplicar los cambios realizados a lo largo de la transacción, y para que los cambios sean persistentes, se deberá ejecutar:

\begin{mycode}{Aplicar y terminar la transacción}{mysql}{}
mysql> COMMIT;
\end{mycode}


Tras esto, los cambios serán realizados y el resto de conexiones verán las modificaciones realizadas.


\subsubsection*{Cancelar transacción}

En caso de que queramos cancelar las ejecuciones realizadas desde el inicio de la transacción, deberemos ejecutar:

\begin{mycode}{Cancelar la transacción y todo lo realizado en ella}{mysql}{}
mysql> ROLLBACK;
\end{mycode}


\subsubsection*{Modificar comportamiento autocommit}
El comportamiento por defecto de MySQL es que cualquier ejecución es una transacción, por lo que realizará el bloqueo de datos necesario o realizará la modificación de los datos. Si queremos cambiar este comportamiento para la sesión actual deberemos hacer:

\begin{mycode}{Modifiar el comportamiento del autocommit}{mysql}{}
mysql> SET autocommit = OFF;
\end{mycode}



\chapter{Gestión de usuarios}

MySQL permite la creación de cuentas que habilitan la conexión de clientes de usuario al servidor y el acceso a los datos que gestiona el servidor (ya sea conexiones mediante CLI o aplicación).

La función principal del sistema de privilegios de MySQL es la de permitir la conexión que se conecta desde un equipo remoto y asociarla a un usuario con permisos sobre una base de datos para que pueda ejecutar funciones tal que  SELECT, INSERT, UPDATE y DELETE. Un usuario también puede recibir permisos para realizar funciones privilegiadas.

Para controlar qué usuarios pueden conectarse, cada cuenta tendrá asignada un credencial de autenticación, como puede ser la contraseña. Las funciones sobre usuarios más habituales son: CREATE USER, GRANT y REVOKE.

El sistema de privilegios de MySQL asegura que \textbf{los usuarios sólo pueden realizar las funciones que le son permitidas}. Cuando un usuario se conecta al servidor MySQL \textbf{su identidad es determinada por}:

\begin{itemize}
    \item El equipo remoto desde el que se realiza la conexión: no es lo mismo que la conexión se realice desde la IP local, desde una IP 192.168.1.100 o desde 172.26.20.2
    \item El nombre de usuario que se haya especificado.
\end{itemize}

Cuando se realice la conexión, el sistema otorga privilegios de acuerdo con la  identidad del usuario y desde donde se recibe la conexión, permitiendo, o no, ciertas acciones sobre los datos.

\begin{center}
    \vspace{-10pt}
    \includegraphics[width=0.6\linewidth]{cliente_servidor.png}
\end{center}


\section{Cuentas de usuarios y contraseñas}
MySQL guarda las cuentas de usuario y sus contraseñas en la tabla \textbf{user} de la base de datos del sistema \textbf{mysql}. Como ya se ha indicado, una cuenta se define con el nombre de usuario y el host desde el que se establece la conexión. MySQL soporta distintos tipos de autenticación, no sólo contraseñas. La autenticación está gestionado por el \href{https://dev.mysql.com/doc/refman/8.0/en/authentication-plugins.html}{plugin de autenticación de cuentas}. Algunos tipos de autenticación que soporta MySQL 8:

\begin{itemize}
    \item Contraseña
    \item Autenticación PAM (para Linux y Mac)
    \item LDAP
    \item Autenticación mediante socket (conexiones locales)
\end{itemize}


\subsection{Creación de usuarios}
Como ya se ha explicado, es importante entender que para que la conexión sea correcta no sólo importa el usuario de conexión, sino desde donde se realiza la misma. Es por ello que a la hora de crear un usuario tendremos que conocer este dato ya que es importante. Aparte, tendremos que poner una contraseña, si es necesario, que sea lo suficientemente segura como para que pase el paso realizado en la \hyperlink{securizar_configuracion_inicial}{securización inicial}. A la hora de crear usuarios \href{https://dev.mysql.com/doc/refman/8.0/en/create-user.html}{hay muchas opciones}.


\subsubsection*{Crear usuario local (SOCKET)}

El usuario solo se va a conectar desde la propia máquina, conexión mediante socket:

\begin{mycode}{Crear usuario que sólo se conecte por socket}{mysql}{}
mysql> CREATE USER 'mikeldi'@'localhost' IDENTIFIED WITH auth_socket;
\end{mycode}


\subsubsection*{Crear usuario local (conexión TCP)}
La conexión va a ser local, pero se va a hacer uso del protocolo TCP, y en este caso es necesario introducir contraseña.

\begin{mycode}{Crear usuario que sólo se conecte por TCP}{mysql}{}
mysql> CREATE USER 'usuario'@'localhost' IDENTIFIED BY 'password';
\end{mycode}


\subsubsection*{Crear usuario para conexión remota (TCP)}
Si queremos que la conexión se pueda realizar desde una IP concreta:

\begin{mycode}{Crear usuario que sólo pueda conectarse desde una IP}{mysql}{}
mysql> CREATE USER 'usuario2'@'192.168.122.1' IDENTIFIED BY 'password';
\end{mycode}

Si queremos que un usuario se pueda conectar desde cualquier IP:

\begin{mycode}{Crear usuario que pueda conectarse desde cualquier IP}{mysql}{}
mysql> CREATE USER 'usuario3'@'%' IDENTIFIED BY 'password';
\end{mycode}


\subsubsection*{Crear usuario y que tenga que se le expire la contraseña}
El usuario se crea con la contraseña del comando, pero cuando se loguee no podrá realizar nada hasta que cambie la contraseña (ver más adelante):

\begin{mycode}{Crear usuario y que la contraseña expire}{mysql}{{\small }}
mysql> CREATE USER 'usuario4'@'%' IDENTIFIED BY 'password' PASSWORD EXPIRE;
\end{mycode}

Si queremos que la contraseña le expire en 10 días:

\begin{mycode}{Crear usuario y que la contraseña expire}{mysql}{{\scriptsize}}
mysql> CREATE USER 'usuario5'@'%' IDENTIFIED BY 'password' PASSWORD EXPIRE INTERVAL 10 DAY;
\end{mycode}



\subsection{Conexión de usuarios}
Dependiendo de cómo se realice la conexión (por socket o TCP) el método de conexión será de una manera u otra.


\subsubsection*{Conexión por socket}
Para poder conectarnos por socket, tenemos que tener acceso a él, siendo lo habitual conexión local. El usuario utilizado será el usuario del sistema:

\begin{mycode}{Conexión por socket desde el usuario root}{console}{}
root@server1:~# mysql
\end{mycode}


\subsubsection*{Conexión remota}
Suponiendo que el servidor MySQL está en la IP 192.168.122.145, la conexión deberá realizarse de la siguiente manera (hay que tener en cuenta el origen de la conexión también).

\begin{mycode}{Conexión al servidor 192.168.122.145}{console}{}
ruben@server1:~$ mysql -u usuario2 -h 192.168.122.145 -p
\end{mycode}


\subsubsection*{Conocer el usuario de conexión:}
Para asegurarnos con qué usuario nos hemos conectado:

\begin{mycode}{Ver el usuario con el que nos hemos conectado}{mysql}{}
mysql> select user();
+------------------------+
| user()                 |
+------------------------+
| usuario2@192.168.122.1 |
+------------------------+
1 row in set (0.00 sec)
\end{mycode}


\subsubsection*{Cambiar la contraseña del propio usuario:}
Si nos conectamos con un usuario que tiene la opción “PASSWORD EXPIRE” activada, para cambiar la contraseña deberemos loguearnos con ese usuario y realizar:

\begin{mycode}{Cambiar la contraseña}{mysql}{}
mysql> set password='password';
\end{mycode}


\subsection{Ver los usuarios que existen}
Los usuarios se guardan dentro de la tabla user en la base de datos mysql. Para poder ver los usuarios creados:

\begin{mycode}{Mirar tabla de usuarios}{mysql}{}
mysql> use mysql;
mysql> select * from user;
\end{mycode}


Para poder ver de otra manera los datos de los usuarios:


\begin{mycode}{Mirar la tabla en modo vertical}{mysql}{}
mysql> select * from user\G
*************************** 1. row ***************************
                 Host: %
                 User: usuario2
          Select_priv: N
          Insert_priv: N
          Update_priv: N
          Delete_priv: N
          Create_priv: N
...
          max_updates: 0
      max_connections: 0
 max_user_connections: 0
               plugin: caching_sha2_password
authentication_string: $A$005$lq-g:Ps27zVBGU8SnP7eg7WK3qnQ6R
     password_expired: N
password_last_changed: 2020-09-05 18:22:11
...
\end{mycode}


\subsection{Limitando los recursos de las cuentas}
Las cuentas de usuarios pueden tener recursos limitados. Estos límites se pueden poner al crear un usuario:

\begin{mycode}{Limitar el número de queries por hora.}{mysql}{\scriptsize}
mysql> CREATE USER 'lim1'@'localhost' IDENTIFIED BY 'frank' WITH MAX_QUERIES_PER_HOUR 20;
\end{mycode}


O se pueden añadir los límites sobre cuentas ya creadas:


\begin{mycode}{Limitar el número de conexiones a 2 para el usuario}{mysql}{}
mysql> ALTER USER 'usuario'@'localhost' WITH MAX_USER_CONNECTIONS 2;
\end{mycode}

\begin{mycode}{Limitar el número de conexiones a 20 por hora}{mysql}{{\small }}
mysql> ALTER USER 'usuario'@'localhost' WITH MAX_CONNECTIONS_PER_HOUR 20;
\end{mycode}

\begin{mycode}{Limitar el número de queries a 500 por hora}{mysql}{}
mysql> ALTER USER 'usuario'@'localhost' WITH MAX_QUERIES_PER_HOUR 500;
\end{mycode}


\begin{mycode}{Limitar el número de updates a 500 por hora}{mysql}{}
mysql> ALTER USER 'usuario'@'localhost' WITH MAX_UPDATES_PER_HOUR 500;
\end{mycode}


\subsection{Borrado de usuarios}
Al borrar usuarios la sentencia “DROP USER” borra una o más cuentas y sus privilegios.

Al hacer un “DROP USER”, si el usuario tiene establecida una conexión no se borrará el usuario podrá seguir haciendo peticiones. Cuando la conexión se cierre será cuando se borre el usuario, y su siguiente conexión no se podrá establecer.

Al borrar un usuario no se pierden los objetos que el usuario haya creado.

\begin{mycode}{Borrar usuario}{mysql}{}
mysql> DROP USER 'usuario'@'localhost';
\end{mycode}


\subsection{Bloqueo de usuarios}
Como borrar un usuario no se puede deshacer, podría ser recomendable bloquear antes la cuenta hasta asegurar al 100\% que el usuario que vamos a borrar no se va a volver a necesitar:

\begin{mycode}{Bloquear un usuario}{mysql}{}
mysql> ALTER USER 'usuario'@'localhost' ACCOUNT LOCK;
\end{mycode}


\subsection{Renombrar un usuario}
Podemos renombrar un usuario, cambiando el usuario y el origen de la conexión. Si la cuenta ya existe obtendremos un error.

\begin{mycode}{Renombrar un usuario}{mysql}{}
mysql> RENAME USER 'usuario'@'localhost' TO 'ruben'@'192.168.122.1';
\end{mycode}


\subsection{Cambiar contraseña al usuario}
Es interesante realizar modificaciones en las contraseñas de usuarios cada cierto tiempo.

\begin{mycode}{Cambiar contraseña de un usuario}{mysql}{}
mysql> SET PASSWORD FOR 'ruben'@'192.168.122.1' = 'password2';
\end{mycode}

\section{Privilegios de usuarios}
Hasta ahora lo que hemos permitido es que un usuario pueda realizar una conexión, pero un usuario conectado no puede realizar ninguna acción sobre tablas ya que no tiene permisos sobre nada. La sentencia \textbf{GRANT} da permisos a las cuentas de usuarios y establece qué operaciones puede realizar.

En la documentación oficial podemos ver todo los \href{https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html}{privilegios que pueden tener los usuarios}.

En la siguiente tabla se muestran sólo unos pocos de los privilegios, y siempre conviene ir a la documentación oficial teniendo en cuenta la versión de MySQL que estamos utilizando, para confirmar los privilegios que existen:


\begin{table}[H]
    \tablestyle
    \begin{tabular}{|p{0.21\linewidth}|p{0.31\linewidth}|p{0.4\linewidth}|}
        \theadstart
        \thead \centering \textbf{Privilege} &
        \thead \centering \textbf{Grant Table Column} &
        \thead \centering \textbf{Context} \tabularnewline
        \tbody
            ALL [PRIVILEGES] & Synonym for “all privileges” & Server administration \\
            ALTER & Alter\_priv & Tables \\
            CREATE & Create\_priv & Databases, tables, or indexes \\
            CREATE USER & Create\_user\_priv & Server administration \\
            CREATE VIEW & Create\_view\_priv & Views \\
            DELETE & Delete\_priv & Tables \\
            DROP & Drop\_priv & Databases, tables, or views \\
            DROP ROLE & Drop\_role\_priv & Server administration \\
            GRANT OPTION & Grant\_priv & Databases, tables, or stored routines \\
            INDEX & Index\_priv & Tables \\
            INSERT & Insert\_priv & Tables or columns \\
            SELECT & Select\_priv & Tables or columns \\
            ... & ... & ... \\
        \tend
    \end{tabular}
    \vspace{-40pt}
\end{table}



Tal como se puede ver, existen multitud de privilegios que se les puede otorgar a los usuarios. Vamos a ver cómo añadir y modificar los permisos de los usuarios.


\subsection{Añadir permisos a usuarios}
Existen muchos tipos de privilegios que podemos otorgar a los usuarios, y veremos una pequeña muestra de ellos.


\subsubsection*{Dar todos los permisos a todo MySQL}

\begin{mycode}{Se le otorgan todos los permisos sobre todo}{mysql}{}
mysql> GRANT ALL ON *.* TO 'nuevo_admin'@'192.168.1.10';
\end{mycode}


\subsubsection*{Dar todos los permisos sobre tablas}

\begin{mycode}{Se le otorgan todos los permisos sobre todas las tablas de la base de datos db1:}{mysql}{}
mysql> GRANT ALL ON db1.* TO 'usuario'@'localhost';
\end{mycode}


\subsubsection*{Dar permisos de SELECT}

Es decir, el usuario podrá realizar consultas SELECT sobre la tabla alumnos de la base de datos db1.

\begin{mycode}{Sólo realizar consultas SELECT sobre la tabla alumnos de la base de datos db1.
    }{mysql}{}
mysql> GRANT SELECT ON db1.alumnos TO 'usuario2'@'%';
\end{mycode}


\subsubsection*{Dar permisos de INSERT}

\begin{mycode}{El usuario podrá realizar inserciones en la tabla asignaturas.}{mysql}{}
mysql> GRANT INSERT ON db1.asignaturas TO 'usuario2'@'%';
\end{mycode}


\subsubsection*{Delegar permisos (GRANT)}

Se puede dar permisos a un usuario para que pueda delegar permisos a otro usuario, pero sólo podrá dar los permisos que él mismo tenga.

\begin{mycode}{Para que el usuario pueda delegar permisos}{mysql}{}
mysql> GRANT ALL ON prueba.* TO 'usuario3'@'%' WITH GRANT OPTION;
\end{mycode}



\subsection{Activar nuevos permisos}
Los nuevos permisos no son aplicados hasta que no se ejecuta la siguiente sentencia:

\begin{mycode}{Para aplicar las modificaciones de permisos}{mysql}{}
mysql> FLUSH PRIVILEGES;
\end{mycode}


\subsection{Eliminar permisos a usuarios}
Se pueden eliminar, o revocar, permisos a usuarios:

\begin{mycode}{Revocar permisos de INSERT al usuario:}{mysql}{}
mysql> REVOKE INSERT ON prueba.asignaturas FROM 'usuario2'@'%';
\end{mycode}


\subsection{Visualizar permisos usuarios}
Ver los permisos de nuestro usuario

\begin{mycode}{Ver los permisos del usuario actual}{mysql}{}
mysql> SHOW GRANTS;
\end{mycode}


\begin{mycode}{Ver los permisos de usuario2}{mysql}{}
mysql> SHOW GRANTS FOR 'usuario2'@'%';
\end{mycode}


\chapter{Gestión de backups en MySQL}

Con la instalación del servidor de MySQL se realiza la instalación de ciertas aplicaciones de administración del servidor, entre las que se encuentran el programa para la realización de backups: \textbf{mysqldump}.

Existen distintas maneras de realizar un backup en MySQL, entre las que se pueden destacar:

\begin{itemize}
    \item \textbf{Backup completo}: Backup de todas las bases de datos que se encuentran instaladas en el servidor, incluyendo las del sistema.
    \item \textbf{Backup de base de datos}: Se realizaría el backup de la base de datos en concreto elegida.
    \item \textbf{Backup de tabla}: En este caso realizaríamos el backup de las tablas de una base de datos que nos interese.
\end{itemize}

Una vez elegido el tipo de backup que vamos a realizar deberemos elegir la herramienta que usaremos para llevar a cabo la estrategia planteada:

\begin{itemize}
    \item \textbf{mysqldump}: Script incluido en las herramientas instaladas junto con MySQL. Por defecto realiza backups en formato de texto plano que podemos guardar en un fichero. Nos permite realizar backup completos, de ciertas bases de datos o de tablas concretas.
    \item \textbf{Percona XtraBackup}: Herramienta creada por la empresa \href{https://www.percona.com/software/mysql-database/percona-xtrabackup}{Percona} que nos permite realizar copias de seguridad sin realizar bloqueos en la base de datos.
    \item \textbf{Otras herramientas}: Existen multitud de herramientas para realizar backups para MySQL. Antes de hacer uso de ellas, deberemos asegurarnos que cumplen con nuestras necesidades.
\end{itemize}

Hay que tener en cuenta que los backups de los datos de las bases de datos no realiza un backup de los ficheros de configuración que se sitúan en \configdir{/etc/mysql} por lo que el backup de esta configuración debe realizarse por algún otro método, ya que la configuración del servidor también es muy importante.


\section{Herramienta propia: mysqldump}
Vamos a hacer uso de la herramienta propia que se instala junto a MySQL, que es mysqldump. Este programa es muy sencillo de utilizar ya que los parámetros que reciben son similares al propio CLI.

Por otro lado, el fichero generado con este programa es un fichero de texto que puede ser visualizado con cualquier editor en caso de necesidad, y fácilmente importado en cualquier otro servidor.

\begin{mycode}{Ayuda del comando mysqldump}{console}{}
root@ubuntu:~# mysqldump
Usage: mysqldump [OPTIONS] database [tables]
OR     mysqldump [OPTIONS] --databases [OPTIONS] DB1 [DB2 DB3...]
OR     mysqldump [OPTIONS] --all-databases [OPTIONS]
For more options, use mysqldump --help
\end{mycode}

Tal como podemos ver, si ejecutamos el script, nos da una ligera idea de cómo podemos realizar un backup con con el mismo. En caso de que el backup sea de una máquina remota para traerlo a local, podremos hacer uso de varios parámetros, por ejemplo \commandbox{mysqldump -u USER -h IP_REMOTA -p}, como cuando usamos el CLI.


\subsection{Backup completo}
Un backup completo de MySQL hará que se guarde toda la información de las bases de datos internas del sistema, en las que se incluyen los usuarios y sus privilegios.

Este sistema es el método más sencillo si queremos realizar después una restauración completa en un nuevo servidor.

\begin{mycode}{Hacer backup completo}{console}{}
root@ubuntu:~# mysqldump --all-databases > backup-completo.sql
\end{mycode}

De esta manera, le hemos indicado al script mysqldump que realice un backup de todas las bases de datos y el contenido obtenido lo vuelque al fichero backup-completo.sql. Este fichero generado es un fichero de texto que contendrá las bases de datos del sistema, usuarios, privilegios…

\subsection{Backup de base de datos}
Podemos realizar el backup únicamente de una, o varias, bases de datos que nos pueda interesar. Para poder realizar el backup de la base de datos que nos interese se hace uso del parámetro “\textbf{--databases}” seguido del nombre de las bases de datos, o en su forma abreviada “\textbf{-B}”. Los dos siguientes comandos son iguales:


\begin{mycode}{Hacer backup de sólo las bases de datos DB1 y DB2}{console}{}
root@ubuntu:~# mysqldump --databases DB1 DB2 > backup-db1-db2.sql
root@ubuntu:~# mysqldump -B DB1 DB2 > backup2-db1-db2.sql
\end{mycode}


Al crear el backup de una, o varias, base de datos de la anterior manera, en el fichero de backup nos aparecerá algo tal que:

\begin{mycode}{Información interna del backup}{mysql}{}
CREATE DATABASE /*!32312 IF NOT EXISTS*/ `DB1`;
USE `DB1`;
\end{mycode}

De esta manera, lo que nos está indicando el backup es que a la hora de restaurar, en caso de que no exista DB1 se creará previamente. Posteriormente realizará el borrado de las tablas y las volverá a crear para realizar el insert de datos.

También podremos obviar el argumento, por lo que en caso de introducir un único parámetro, lo tomará com la base de datos de la que realizar copia de seguridad.

\begin{mycode}{Hacer backup de una única base de datos}{console}{}
root@ubuntu:~# mysqldump DB1 > backup-DB1.sql
\end{mycode}

Al hacer el backup de esta manera, en el fichero no aparecerá la creación de la base de datos, por lo que a la hora de realizar la importación tendremos que hacerlo sobre una base de datos ya creada.

\subsection{Backup de una tabla}
Puede darse casos que nos interese realizar backups de una única tabla, o poder hacer backups de una tabla de manera más seguida, y para ello podremos ejecutar:

\begin{mycode}{Hacer backup de la tabla “asignaturas” de “DB1”}{console}{}
root@ubuntu:~# mysqldump DB1 asignaturas > backup-db1-asignaturas.sql
\end{mycode}

De esta manera hacemos backup de la tabla “asignaturas” de la base de datos DB1.


\section{Importar un backup}
Tal como hemos visto existen distintas maneras de realizar un backup, por lo que dependiendo de cómo es el backup que queremos importar, se hará de una manera u otra.

Hay que entender que la importación de un backup puede suponer la pérdida de datos de las bases de datos del servidor donde importamos el backup, por lo que hay que asegurarse muy bien qué queremos restaurar y dónde lo vamos a restaurar para no haya pérdida de datos donde no queremos.

\warnbox{\textbf{Importar datos de un backup puede suponer la pérdida de datos en el servidor donde se realiza la importación.}}

También es lógico pensar que dependiendo de la herramienta utilizada para realizar el backup la importación del mismo no tiene por qué ser igual, ya que distintas herramientas pueden dar lugar a distintos tipos de ficheros.

\warnbox{\textbf{Antes de restaurar un backup confirma cómo se hizo y cómo haces la importación.}}

\subsection{Importar backups de mysqldump}
Como se ha comentado previamente, mysqldump se instala junto con el servidor, y debido a que es una herramienta sencilla de usar, su importación también es sencilla. Para realizar la importación de este tipo de backups haremos uso del propio CLI  \commandbox{mysql}.


\subsubsection{Importar un backup completo}
\textbf{Al importar un backup completo haremos la sustitución de todas las tablas internas de MySQL} por los datos que haya en el backup. Por lo tanto, nos tendremos que asegurar muy bien de que el servidor donde realizaremos la importación de datos es un servidor sin datos importantes.

Para importar un backup completo haremos:

\begin{mycode}{Importar un backup completo}{console}{}
root@ubuntu:~# mysql < backup-completo.sql
\end{mycode}

Con esto estaremos indicando que el contenido del fichero de backup se importe sobre la conexión que hemos realizado, en este caso en local.


\subsubsection{Importar un backup de una base de datos}
Tal como hemos visto antes, a la hora de crear el backup de una, o varias, base de datos se puede realizar añadiendo el parámetro “--databases”,  “-B” o sin especificar nada, sólo la base de datos. Dependiendo de cómo se haya creado el backup, la importación variará:

\begin{itemize}
    \item Si el backup se ha realizado con “\textbf{--databases}” o “\textbf{-B}” en el propio backup aparece:
\begin{mycode}{”Create database” en el propio fichero de backup}{mysql}{}
CREATE DATABASE /*!32312 IF NOT EXISTS*/ `DB1`;
\end{mycode}
    y para realizar la importación:
\begin{mycode}{Importar un backup completo}{console}{}
root@ubuntu:~# mysql < backup-DB1.sql
\end{mycode}

    \item Si no hemos especificado más que el nombre de la base de datos, en el backup no aparece la creación o uso de la base de datos, por lo que tendremos que indicarlo en la importación, y \textbf{la base de datos “restaurado” debe existir previamente}.
\begin{mycode}{Importar un backup completo en una base de datos llamada “restaurado”}{console}{}
root@ubuntu:~# mysql restaurado < backup-DB1.sql
\end{mycode}

\end{itemize}


\subsubsection{Importar un backup de una tabla}
Por último, si queremos importar un backup donde sólo existen tablas, a la hora de importar deberemos indicar en qué base datos queremos realizar la importación, ya que en el backup no aparece dicha información. Por ejemplo:

\begin{mycode}{Importar un backup de una tabla en la base de datos “restauracion”}{console}{}
root@ubuntu:~# mysql restauracion < backup-db1-asignaturas.sql
\end{mycode}

De esta manera estamos indicando al CLI que el contenido del fichero de backup se importe sobre la base de datos \textit{restauración}. Lógicamente esta base de datos debe estar creada previamente.

\hypertarget{monitorizacion_de_sgbds}{anchor text}
\chapter{Monitorización de SGBDs}
En el caso que nos ocupa, el de los Sistemas Gestores de Bases de Datos, aparte de la \hyperlink{sistemas_de_monitorizacion}{monitorización básica comentada en el anexo}, necesitaremos monitorizar el estado del SGBD propiamente dicho. Para ello, de nuevo, se crearía una plantilla específica para cada SGBD que podamos tener en nuestra infraestructura. No será lo mismo monitorizar un servidor basado en MySQL o un Oracle, aunque muchos checks a comprobar deban ser lo mismo, pero la manera en la que se realizará la comprobación en el servidor será distinta.

Entre las comprobaciones que podemos realizar en un SGBD nos podemos encontrar con:
\begin{itemize}
    \item Servicio SGBD arrancado
    \item Cantidad de RAM utilizada por el SGBD
    \item Número de conexiones a las bases de datos
    \item Número de hilos en ejecución del SGBD
    \item Número de queries en ejecución
    \item Número de tablas en memoria
    \item Número de tablas bloqueadas
    \item …

\end{itemize}


\section{Monitorizar MySQL}
Todo lo expuesto \hyperlink{sistemas_de_monitorizacion}{en el anexo} es referente a los sistemas de monitorización en general, y es similar en todos ellos. Tal como se ha comentado previamente, cuando un servidor cuenta con un servicio éste debe ser monitorizado, y dependiendo del servicio a monitorizar se realizará una serie de comprobaciones u otras.

A la hora de monitorizar un sistema gestor de bases de datos deberíamos tener en cuenta al menos las siguientes comprobaciones, y en el caso de MySQL:
\begin{itemize}
    \item Número de conexiones actuales (usuarios/conexiones tiene el servicio)
    \item Tiempo del servicio activo (uptime)
    \item Número de hilos en ejecución
    \item Tamaño de memoria utilizado
    \item Tamaño de memoria caché utilizado
    \item Número de tablas en memoria
    \item Número de slow queries
    \item Número de conexiones abortadas
    \item Número de queries totales
\end{itemize}

En servidores en alta disponibilidad, deberíamos comprobar, en caso de un clúster:
\begin{itemize}
    \item Número de nodos en el clúster
    \item Estado general del clúster
    \item Latencia entre los nodos del clúster
    \item Si el nodo está conectado al clúster
    \begin{itemize}
        \item  Puede pasar que un nodo “se salga” del clúster (o lo saquemos) para realizar mantenimiento
    \end{itemize}
\end{itemize}

Si el servidor está dentro de una infraestructura de \textbf{Primario → Réplica}:
\begin{itemize}
    \item Estado de la replicación
    \item Retraso de la replicación
    \item Tamaño del binlog
\end{itemize}

Las comprobaciones expuestas son un mero ejemplo, y existen muchas más que podemos realizar a nuestros sistemas. Para poder realizar este tipo de monitorización podemos hacer uso de scripts propios (ya que muchas de las comprobaciones son consultas a variables de estado de MySQL), scripts creados por otras personas o scripts de monitorización hechos de manera exclusiva para MySQL.

\subsection{Scripts propios}
Para realizar gran parte de los checks expuestos previamente se puede hacer uso de scripts propios, ya que pueden realizar consultas de las variables de estado para comprobar y determinar si el estado es correcto.

Un ejemplo de script creado \textit{ad hoc} para nuestro sistema podría ser:

\begin{mycode}{Script propio para monitorizar}{bash}{}
#!/bin/bash
mysql -e "SHOW STATUS LIKE 'Slow_queries';" -N | awk '{print $2}'
\end{mycode}


\subsection{Percona monitoring tools}
La alternativa a hacer uso de scripts propios es usar programas o scripts realizados por terceros, que estén ampliamente probados y que tienen detrás un equipo que quizá sea más amplio que el nuestro, y por tanto esté mejor probado.

La empresa Percona tiene un par de soluciones sobre monitorización de SGBDs (no sólo para MySQL, también para \href{https://www.postgresql.org/}{PostgreSQL} y \href{https://www.mongodb.com/}{MongoDB}), que son:

\begin{itemize}
    \item \href{https://www.percona.com/software/database-tools/percona-monitoring-and-management}{\textbf{Percona Monitoring and Management}}: Un sistema completo de monitorización, interfaz web incluída, que podremos \href{https://www.percona.com/software/pmm/quickstart}{instalar} en nuestros propios servidores. Podemos ver aquí una \href{https://pmmdemo.percona.com/graph/}{demo}.

    \includegraphics[width=\linewidth]{percona_tools.png}

    \item \href{https://www.percona.com/software/database-tools/percona-monitoring-plugins}{\textbf{Percona Monitoring Plugins}}: En este caso son un conjunto de plugins (o scripts) que podremos utilizar en nuestro sistema de monitorización propio (Nagios, Centreon o Cacti). En la \href{https://www.percona.com/doc/percona-monitoring-plugins/LATEST/index.html}{documentación} explican cómo hacer uso de ellos.
\end{itemize}



\chapter{Alta Disponibilidad en un SGBD}

La alta disponibilidad en servidores se puede definir como el diseño de infraestructura (y su implantación) que asegura la continuidad del servicio y que no tiene un único punto de fallo.

Es lógico entender que un servicio debe de ser contínuo en el tiempo, ya que debe de dar servicio de manera continuada para que los usuarios puedan acceder a él. Pero para que esta premisa sea efectiva, y para asegurarnos que así sea, \textbf{la infraestructura debe de estar redundada y carecer de puntos de fallos en su diseño}.  Esto quiere decir, que de cada servicio y cada posible punto de fallo, deberá haber al menos dos de ellos (dos tomas eléctricas separadas, dos servidores que otorguen el servicio, dos conexiones a internet, … ).

Es habitual que un sistema en Alta Disponibilidad deba de estar pensado desde el diseño. Algunos tipos  de servicios pueden empezar como un único servidor y posteriormente realizar un \hyperlink{escalado_horizontal}{escalado horizontal}, formando la alta disponibilidad, mientras que para otros \textbf{el diseño en alta disponibilidad debe de estar pensado desde el comienzo} (habitualmente en algunos tipos de \hyperlink{cluster}{clusters}).


\section{Importancia de un sistema en Alta Disponibilidad}

Como se ha citado previamente, la alta disponibilidad nos va a asegurar al menos dos grandes ventajas:

\begin{itemize}
    \item Una continuidad en el servicio
    \item Un diseño libre de puntos de fallos únicos, gracias a la redundancia.
\end{itemize}

La redundancia permitirá que en caso de fallo de algún equipamiento/servicio, al estar redundando, no afecte al servicio. Gracias al \hyperlink{monitorizacion_de_sgbds}{sistema de monitorización} seremos capaces de ver el problema y solventarlo lo antes posible. De estar el diseño correcto, el servicio mantendrá su actividad, mientras que por el contrario, si ha habido algún fallo en el diseño de infraestructura (o el problema es más grave de lo esperado) el servicio se verá afectado.


\section{Tipos de Alta Disponibilidad}
Existen muchos tipos de alta disponibilidad dependiendo de en qué capa de infraestructura estemos hablando. Por poner unos ejemplos:

\begin{itemize}
    \item \textbf{Redundancia eléctrica}: Los servidores normalmente cuentan con doble fuente de alimentación, por lo que cada fuente de alimentación debe de estar conectada a una toma eléctrica completamente separada de la otra.
    \item \textbf{Redundancia de conectividad física}: El acceso a internet debe de ser redundado.
    \item \textbf{Redundancia de conectividad LAN}: El acceso a la LAN/DMZ/red de servicio debe de estar redundado (stacks de switches, LACPs configurados en switches y servidores, … ).
    \item \textbf{Redundancia de servidores}: Debe de existir una redundancia de servidores para asegurar que el servicio funcione en más de un servidor físico.
    \item \textbf{Redundancia de servicio}: El servicio que se ofrece debe de estar redundado entre los distintos servidores.
\end{itemize}


La alta disponibilidad también se puede diferenciar como:


\begin{itemize}
    \item \textbf{Alta disponibilidad real}: En caso de que haya algún problema el servicio continúa como si no hubiese pasado nada, gracias a la redundancia completa de servicios/dispositivos.
    \item \textbf{Alta disponibilidad pasiva}: En caso de error, los servidores activos serían los que reciben el impacto del problema y hay que escalar los servidores pasivos a modo activo para que comiencen a funcionar otorgando el servicio. Como se puede presuponer, esta modificación puede ser realizada de manera automática o de manera manual (lo que llevaría algo de tiempo, y por tanto el servicio se vería afectado).
\end{itemize}


En lo que se refiere a los SGBDs, y en concreto a MySQL, podemos diferenciar entre los siguientes tipos de alta disponibilidad que veremos a continuación.


\subsection{Primario - Replica}
\begin{wrapfigure}{r}{0.4\linewidth}
    \centering
    \vspace{-50pt}
    \includegraphics[width=\linewidth]{primario_replica.png}
    \vspace{-30pt}
\end{wrapfigure}
También denominado “Primario → Réplica” (antiguamente denominado “Maestro → Esclavo”). Es un tipo de alta disponibilidad pasiva en el que contamos con dos servidores.

El principal/primario/master es el que recibe todas las modificaciones que se realizan en la base de datos, y por tanto debe de estar en funcionamiento para poder recibir las modificaciones de datos.

El secundario/réplica/esclavo, como su nombre indica, recibe los datos replicados del principal. Es posible recibir en este servidor peticiones de “SELECTS” para que así quite carga al principal, pero hay que asegurarse de no recibir ni INSERTS ni UPDATES.

En caso de que exista algún problema con el servidor primario, el servidor de réplica deberá pasar a ser el primario, por lo que habrá que hacer que también reciba los inserts. En caso de que el servidor haya sido configurado en modo “sólo lectura”, habrá que quitarlo.

Podemos destacar de este tipo de replicación las siguientes características:


\begin{itemize}
    \item Sistema sencillo de replicación.
    \item La sincronización es asíncrona por defecto. El servidor secundario no tiene por qué estar todo el rato conectado. Cuando se conecte, pedirá y recibirá todas las modificaciones desde la última realizada.
    \item Dependiendo de la configuración realizada en el servidor secundario, se replicará todo, sólo alguna base de datos o sólo alguna tabla.
    \item Para no cargar al servidor primario, los backups se pueden realizar sobre el servidor de réplica.
    \item Se pueden realizar réplicas a larga distancia, estando el servidor de réplica en otro datacenter.

\end{itemize}


Hay que tener en cuenta que si el servidor réplica se detiene, \textbf{las modificaciones del primario se guardan en unos ficheros llamados \underline{binlogs}}. Estos ficheros se suelen configurar para almacenar una cantidad de datos precisa, por lo que si el tiempo de caída del servidor réplica supera el tiempo que los binlogs almacenan información, al retomar la actividad no obtendrá todos los datos del servidor primario.



\subsection{Primario - Primario}
\begin{wrapfigure}{r}{0.4\linewidth}
    \centering
    \vspace{-50pt}
    \includegraphics[width=\linewidth]{primario_primario.png}
    \vspace{-30pt}
\end{wrapfigure}
Una replicación “Primario ←→ Primario” en MySQL no es más que una replicación “Primario → Réplica” de doble sentido.

Esto quiere decir que ambos servidores pueden recibir todo tipo de consultas y modificaciones. El problema es que podría darse el caso de que dos INSERT simultáneos en ambos servidores obtengan identificadores auto-incrementales idénticos, lo que daría error a la hora de realizar los INSERT.

Por lo tanto, para evitar eso, lo que se hace es modificar las variables auto-increment para que en uno de los servidores se den números pares y en el otro impares.  Estas variables son:


\begin{itemize}
    \item \textbf{auto\_increment\_increment}: es el incremento que se realiza entre valor y valor de “auto\_increment”. En este caso, debe de ser “2” en ambos servidores porque es el número de servidores que tenemos.
    \item \textbf{auto\_increment\_offset}: determina el comienzo del sistema “auto\_increment” en nuestro servidor. En este caso, la variable obtendrá valores distintos en los servidores:
    \begin{itemize}
        \item “1”: en un servidor, por lo tanto, en este siempre habrá valores impares.
        \item “2”: en el otro servidor, por lo que los valores serán pares.
    \end{itemize}
\end{itemize}


Para que ambos servidores reciban peticiones, la aplicación que las pida podrá preguntar a ambos servidores o podremos tener un servidor proxy por delante que realice un balanceo de peticiones a ambos servidores.



\subsection{MySQL Cluster}
\begin{wrapfigure}{r}{0.4\linewidth}
    \centering
    \vspace{-50pt}
    \includegraphics[width=\linewidth]{mysql_cluster.png}
    \vspace{-50pt}
\end{wrapfigure}
Como ya se ha comentado previamente, MySQL Cluster es un SGBD distinto a MySQL Community, y el tipo de Alta Disponibilidad que podemos obtener con él es distinto a los citados previamente. En este caso, el número de servidores mínimos con los que deberemos contar será de 3, y a partir de ahí deberá ser siempre número impar.

No entraremos en detalle en este sistema, pero a grandes rasgos podemos pensar de él como un sistema “Primario ←→ Primario” multi servidor. \textbf{En este caso la sincronización es síncrona}, es decir, \textbf{antes de dar por terminada una sentencia se asegura que está replicada en todos los servidores}.


\section{Sistema “Primario → Réplica” con MySQL}
Como se ha visto, MySQL permite distintos tipos de replicación y creación de infraestructura en Alta Disponibilidad. En nuestro caso, vamos a optar por la más sencilla de todas ellas, que es la replicación “Primario → Réplica”.

Para ello, contaremos con dos servidores Ubuntu 20.04 recién instalados con MySQL Community también recién instalados, y a partir de aquí comenzaremos a realizar la configuración oportuna que necesitaremos para conseguir nuestro objetivo.


\subsection{A tener en cuenta}
Antes de comenzar con la configuración tiene que quedar clara una serie de conceptos:

\begin{itemize}
    \item Los datos deben de ser insertados/actualizados en el principal.
    \item Una vez realizadas las modificaciones son escritas en los \textbf{binary-log} del principal.
    \item El servidor réplica, para evitar problemas, debería estar en modo “sólo lectura”.
    \item El servidor réplica se conecta al primario en busca de las modificaciones (en los binary-log) y ejecutará las órdenes en el propio servidor réplica.
    \begin{itemize}
        \item El servidor réplica mantiene la posición del binary-log en la que se encuentra.
        \item MySQL acepta replicación de una serie a una versión superior, pero nunca haciendo saltos de dos versiones.
    \end{itemize}
    \item Cada servidor contará con \textbf{server-id} distinto.
\end{itemize}

\subsection{Creación del sistema principal/origen}
Con todo lo citado previamente, los pasos para crear el sistema primario son los siguientes:

\begin{enumerate}
    \item Configurar servidor con IP estática
    \item Modificar configuración de MySQL
    \item Crear usuario de replicación
    \item Hacemos backup inicial de los datos.
\end{enumerate}

Se obvia el primer paso ya que es configuración del sistema operativo y \hyperlink{configurar_ip_estatica_ubuntu}{aparece en el anexo}.


\subsubsection{Configuración del servidor principal}
En el fichero de configuración del servidor principal tendremos que modificarlo para que aparezca la siguiente configuración

\begin{mycode}{Configuración MySQL del primario}{ini}{}
[mysqld]
...
server-id = 1
log_bin = /var/log/mysql/binlog
binlog_expire_logs_seconds     = 2592000
max_binlog_size = 100M
\end{mycode}

Una vez modificado el fichero de configuración, el servidor debe ser reiniciado. Para comprobar si el servidor está en modo “primario” podemos consultarlo de la siguiente manera:


\begin{mycode}{Comprobar estado del primario}{mysql}{}
mysql> SHOW MASTER STATUS \G
*************************** 1. row ***************************
File: mysql-bin.000001
Position: 1397
Binlog_Do_DB:
Binlog_Ignore_DB:
Executed_Gtid_Set:
1 row in set (0.00 sec)
\end{mycode}

Podemos observar el fichero “mysql-bin” y la posición del mismo del servidor principal.


\subsubsection{Crear usuario de replicación}
Como se ha comentado previamente, el servidor réplica se conectará al principal, por lo que tiene que existir un usuario con el que poder conectarse y comprobar el estado de los binlogs.

\begin{mycode}{Crear usuario para la replicación}{mysql}{{\footnotesize }}
CREATE USER 'repl'@'192.168.1.21' IDENTIFIED WITH mysql_native_password BY 'password';
GRANT REPLICATION SLAVE ON *.* TO 'repl'@'192.168.1.21';
FLUSH PRIVILEGES;
\end{mycode}


Hay que tener en cuenta que la IP tendrá que ser la IP del servidor réplica y será con este usuario con el que realizará la conexión. Es obligatorio poner “mysql\_native\_password” ya que el nuevo sistema de autenticación “caching\_sha2\_password” necesita de certificados para realizar la conexión.


\subsubsection{Backup inicial del servidor primario/origen}
Una vez configurado el servidor en modo primario, realizaremos el backup inicial que posteriormente será cargado en el servidor réplica. Debido a la configuración que hemos realizado, el servidor réplica deberá conocer a partir de qué posición del binlog obtener las modificaciones después de haberse realizado el backup. Por tanto, el backup debe realizarse de la siguiente manera:

\begin{mycode}{Hacer backup inicial para la replicación}{console}{}
root@server1:~# mysqldump --all-databases --source-data > dbdump.sql
\end{mycode}

Y como se puede comprobar, el parámetro nuevo es “--source-data”, que hará que dentro del fichero de backup aparezca (es posible que en el futuro aparezca como “PRIMARY” o “PRIMARY\_LOG\_”:


\begin{mycode}{Hacer backup inicial para la replicación}{mysql}{{\small }}
...
--
-- Position to start replication or point-in-time recovery from
--
CHANGE MASTER TO MASTER_LOG_FILE='mysql-bin.000001', MASTER_LOG_POS=1397;
...
\end{mycode}

Esta información es el punto exacto en el que se ha quedado el binlog (tanto en qué fichero como en qué posición) cuando se ha realizado el backup. Esta información la necesitaremos para posteriormente en el servidor réplica indicarle que es a partir de este punto el que deberá pedir la información a replicar.


\subsection{Creación del sistema secundario/réplica}
En el caso del servidor secundario los pasos a realizar son:

\begin{enumerate}
    \item Configurar IP estática.
    \item Modificar la configuración de MySQL.
    \item Importar backup.
    \item Configuración de conexión  al servidor primario.
    \item Comenzar la replicación.
    \item Comprobar estado de la replicación.
\end{enumerate}


\subsubsection{Modificar configuración en el servidor RÉPLICA}
En este caso, la modificación que debemos de realizar es cambiar el \textbf{server-id}, que tendrá que ser distinto al del primario, y podremos poner de manera opcional el nombre del servidor réplica en la variable \textbf{report\_host}.


\begin{mycode}{Configuración MySQL del servidor réplica}{ini}{}
[mysqld]
...
server-id = 2
# la opción report_host es opcional
report_host = server2
\end{mycode}


\subsubsection{Importar el backup}
Tal como se realiza de cualquier backup, teniendo el backup en el propio servidor réplica:

\begin{mycode}{Restaurar backup inicial}{console}{}
root@server1:~# mysql < dbdump.sql
\end{mycode}


\subsubsection{Configuración de conexión al primario}
Desde el CLI de MySQL debemos realizar la siguiente sentencia, teniendo en cuenta:
\begin{itemize}
    \item La IP de nuestro servidor primario.
    \item Los datos del usuario de replicación creado previamente.
    \item Los datos de binlog que hemos podido obtener del fichero de replicación.
\end{itemize}

\begin{mycode}{Configuración de conexión al servidor primario}{mysql}{}
mysql> CHANGE REPLICATION SOURCE TO
          SOURCE_HOST='192.168.1.129',
          SOURCE_USER='repl',
          SOURCE_PASSWORD='password',
          SOURCE_LOG_FILE='mysql-bin.000001',
          SOURCE_LOG_POS=1397;
\end{mycode}

\subsubsection{Comenzar la replicación}
Ahora el servidor réplica tiene que comenzar la replicación a partir de la posición y del fichero del bin-log que se ha configurado. Es de suponer que el servidor primario ha recibido modificaciones, y por tanto, deben ser replicadas.

\begin{mycode}{Comenzar la replicación}{mysql}{}
mysql> START REPLICA;
\end{mycode}


\subsubsection{Comprobar estado de la replicación}
La replicación es un proceso que debe de ser monitorizado y nos debemos asegurar que funciona de manera correcta. Para conocer cuál es el estado de la replicación podremos obtenerlo ejecutando:

\begin{mycode}{Comprobar estado de la replicación}{mysql}{}
mysql> SHOW REPLICA STATUS \G
*************************** 1. row ***************************
         Replica_IO_State: Waiting for source to send event
              Source_Host: 192.168.200.10
              Source_User: repl
              Source_Port: 3306
            Connect_Retry: 60
          Source_Log_File: mysql-bin.000001
      Read_Source_Log_Pos: 3256
           Relay_Log_File: ubuntu-relay-bin.000003
            Relay_Log_Pos: 324
    Relay_Source_Log_File: mysql-bin.000001
       Replica_IO_Running: Yes
      Replica_SQL_Running: Yes
...
    Seconds_Behind_Source: 0
...
Replica_SQL_Running_State: Replica has read all relay log;
waiting for more updates
\end{mycode}


Como alternativa, también podremos ver desde el servidor primario cuántos servidores réplica tiene, pero la información proporcionada es escasa, pero nos puede servir para obtener información de un servidor no instalado por nosotros.

\begin{mycode}{Estado de servidores réplica desde el primario}{mysql}{}
mysql> SHOW REPLICAS;
+-----------+---------+------+-----------+---------------------------+
| Server_Id | Host    | Port | Source_Id | Replica_UUID              |
+-----------+---------+------+-----------+---------------------------+
|         2 | server2 | 3306 |         1 | 9fb33895-4c78-11ec-b23... |
+-----------+---------+------+-----------+---------------------------+
1 row in set (0,00 sec)
\end{mycode}


\section{Ficheros binary logs}
Durante la replicación se han usado los binary logs, y para activarlos se ha tenido que configurar en el servidor primario/origen las siguientes variables de configuración:
\begin{itemize}
    \item log\_bin = /var/log/mysql/binlog
    \item binlog\_expire\_logs\_seconds = 2592000
    \item max\_binlog\_size = 100M
\end{itemize}

El significado de las variables es el siguiente:

\begin{itemize}
    \item \textbf{log\_bin}: path donde se van a guardar los binlogs. Siendo el ejemplo de arriba, obtendremos unos ficheros tal que:
    \begin{itemize}
        \item /var/log/mysql/mysql-bin.000001
        \item /var/log/mysql/mysql-bin.000002
        \item /var/log/mysql/mysql-bin.000003
        \item …
    \end{itemize}
    \item \textbf{binlog\_expire\_logs\_seconds}: el número de segundos que pasarán antes de que los binlogs se borren de manera automática. Significa que tendremos tantos ficheros binlog como para poder guardar los cambios acontecidos en la base de datos durante la cantidad de segundos puesta.

    Eso significa, que si nuestra réplica está menos de 30 días sin conectarse al primario (por un fallo de conectividad), podríamos llegar a recuperar la replicación sin necesidad de rehacer nada, sólo consiguiendo que la conectividad vuelva a funcionar. Por otro lado, la cantidad de datos almacenados en esa cantidad de días en los ficheros binlog puede hacer que nuestro servidor ocupe mucho espacio, por lo que se debería pensar en guardar esos binlogs en otra partición o modificar la variable.

    \item \textbf{max\_binlog\_size}: tamaño máximo que alcanzará cada fichero binlog. En caso de llegar al tamaño especificado, se creará un nuevo fichero binlog, modificando el índice y el nombre del nuevo fichero. El tamaño máximo que puede tener cada binlog es 1GB.
\end{itemize}


\subsection{Borrado de binlogs}
En caso de necesidad (por falta de espacio en el servidor), podemos realizar el borrado de ficheros binlogs siempre y cuando nos hayamos asegurado que la réplica ya los ha recibido (es decir, la replicación esté correcta, o el binlog por el que vaya la réplica sea mayor al que queremos borrar).

\warnbox{\textbf{Antes de borrar binlogs, debemos asegurar que los servidores réplica están sincronizados}}

Podemos realizar el borrado de binlogs indicando el fichero:

\begin{mycode}{Borrado de binlogs indicando el fichero}{mysql}{}
mysql> PURGE BINARY LOGS TO 'mysql-bin.000010';
\end{mycode}


Como alternativa, también podemos especificar que borre todos los logs anteriores a la fecha y hora indicada, borrando así los ficheros necesarios para ello. De nuevo, nos tendremos que asegurar de que la replicación esté correcta antes de hacerlo.


\begin{mycode}{Borrado de binlogs indicando la fecha}{mysql}{}
mysql> PURGE BINARY LOGS BEFORE '2020-11-11 00:00:00';
\end{mycode}