
\graphicspath{{img/redes/}}

\chapter{Arquitectura en capas}
Un sistema de comunicación se pueden diferenciar en distintos niveles en los que cada uno realiza una función independiente, pero que a su vez interactúan con los niveles limítrofes.

\begin{center}
    \vspace{-10pt}
    \includegraphics[width=0.4\linewidth]{comunicacion-esquema.png}
    \vspace{-10pt}
\end{center}

Este ejemplo es un modelo simplificado de comunicación, y dentro de una arquitectura de red de ordenadores pueden existir más capas en las que pueden existir distintas funciones extra que no aparecen en este esquema.

\section{Origen}

Al comienzo de las redes de ordenadores cada empresa creaba su propio sistema de comunicación creando su propio hardware y software, lo que hacía imposible la interconexión entre equipamiento de distintas empresas.

Estos sistemas de comunicación constan de unas reglas que los nodos deben conocer para poder comunicarse entre sí, y a ese conjunto de reglas se les denomina \textbf{protocolo de comunicación}.


Para que eso hoy en día no suceda ya que las redes están definidas en varios estándares, como veremos más adelante.

\infobox{Un \textbf{estándar} es un conjunto de normas que pueden abarcar distintos niveles (tanto software como hardware) que ha sido aceptado, o creado, por la gran mayoría de las empresas del sector para poder realizar la interconexión e intercomunicación entre sí.}


\section{Ventajas de la división en capas}

La división en capas nos permite:
\begin{itemize}
    \item Dividir el proceso de comunicación en procesos más pequeños.

    \item Aislar las funciones de cada capa. De esta manera, en caso de realizar modificaciones en la misma, no afecta al resto de capas.

    \item Ocultar la implementación al resto de capas. Siguiendo con el punto anterior, una capa utilizará los servicios de su capa inferior sin saber cómo realiza sus funciones.

    \item Cada capa puede constar de distintos estándares, facilitando la interconexión de distintas tecnologías
\end{itemize}

Una arquitectura de red en capas se implementa por medio de distintos protocolos, formando una familia de protocolos para facilitar la comunicación de distintos sistemas y equipos en la red.

\infobox{Una arquitectura en capas nos permite que cada capa actúe de manera independiente y que incluya sus propios protocolos. Cada capa dispone de una serie de servicios que ofrece a su capa limítrofe superior.}

Desde el comienzo de las redes de ordenadores han existido distintas familias de protocolos, y se puede considerar que hubo una \href{https://en.wikipedia.org/wiki/Protocol_Wars}{guerra de protocolos durante las décadas de 1970 a 1990}. Empresas, organizaciones y países se posicionaban sobre cuál sería el mejor protocolo de comunicaciones y el que saldría ganador para el uso a nivel internacional.

Por destacar algunos protocolos que ya no se usan:

\begin{itemize}
    \item \textbf{\href{https://en.wikipedia.org/wiki/Systems_Network_Architecture}{SNA}} creado en 1974 por IBM.
    \item \textbf{\href{https://en.wikipedia.org/wiki/NetBIOS_Frames}{NetBEUI}} de Microsoft. Que evolucionó a NetBIOS sobre TCP/IP que hoy día se usa en Windows Server.
    \item \textbf{\href{https://en.wikipedia.org/wiki/IPX/SPX}{IPX/SPX}} de Novell.
\end{itemize}

\section{Modelo de referencia OSI}
El modelo de interconexión de sistemas abiertos, conocido como “modelo \textbf{OSI}” (\textit{\textbf{O}pen \textbf{S}ystems \textbf{I}nterconnection} en inglés) es un \textbf{modelo de referencia (teórico)} que busca estandarizar las funciones de comunicación para un sistema informático siendo agnóstico a la tecnología utilizada para realizar la implementación y a los protocolos utilizados en cada capa.

El diseño comenzó en 1977 tratando de terminar con la \href{https://en.wikipedia.org/wiki/Protocol_Wars}{guerra de protocolos} comentada previamente, y la Organización Internacional de Estandarización (\textit{International Organization for Standardization}, o \textbf{ISO} en inglés)  terminó por definir el estándar ISO-7498 en 1984.


\subsection{Capas en el modelo OSI}
El modelo OSI está compuesto por siete capas numeradas del 1 al 7 siendo la 1 la más baja y haciendo referencia a la parte física de la red.


%TODO: modificar tabla?
\begin{yukitblr}{X X X[3,l]}
    Capa & Nombre de la unidad de datos & Función \\

    7ª - Aplicación & Datos
    & APIs de alto nivel, como compartir recursos y acceso remoto a archivos. \\

    6ª - Presentación & Datos
    & Traducción de datos entre un servicio de red y una aplicación, que incluye la codificación de caracteres, la compresión de datos y el cifrado y descifrado de datos.
    \\

    5ª - Sesión & Datos
    & Manejo de sesiones de comunicación, por ejemplo el continuo intercambio de información en forma de múltiples transmisiones hacia ambos lados entre dos nodos.
    \\

    4ª - Transporte & Segmento, Datagrama
    & Transmisión de segmentos de datos confiable entre puntos de red, incluyendo la segmentación, el acknowledgement y la multiplexación.
    \\

    3ª - Red & Paquete
    & Estructura y manejo de una red multinodo. Incluye el direccionamiento, el ruteo y el control de tráfico traffic control.
    \\

    2ª - Enlace & Trama
    & Transmisión de datos confiable entre dos nodos conectados mediante una capa física.
    \\

    1ª - Física & Bit, Baudios
    & Transmisión y recepción de flujos de bits sin procesar por un medio físico.
    \\
\end{yukitblr}







\section{Arquitectura TCP/IP}





\chapter{Conexión de redes a nivel físico}



\hypertarget{sistemas_transmision}{}
\section{Sistemas de transmisión}

guiados:
- cable par trenzado
- coaxial
- optica
FTTH

no guiados
- radiofrecuencia



\chapter{Conexión de redes a nivel de enlace de datos}


\section{Administración de switches}



\chapter{Interconexión de redes}
Hoy en día no suele ser habitual tener redes completamente aisladas, ya que la comunicación sólo se podría realizar entre los nodos y los dispositivos de la misma.

En el momento en el que una red quiera comunicarse con otra vamos a necesitar de un dispositivo que realice de intermediación para el intercambio de paquetes, y ese dispositivo es el \textbf{router}.

\section{Router}

\begin{wrapfigure}{r}{0.36\linewidth}
    \centering
    \vspace{-20pt}
    \includegraphics[width=\linewidth]{OSI_model_router.png}
    \vspace{-32pt}
    \captionof{figure}{Router en el modelo OSI (\href{https://es.wikipedia.org/wiki/Router\#/media/Archivo:OSI_model_router.png}{wikipedia})}
    \vspace{-10pt}
\end{wrapfigure}

Un router (o encaminador) es el encargado de enrutar (o encaminar) los paquetes que recibe de una red a otra red buscando la ruta más adecuada para ello.

Un router puede “unir” redes, por lo que para ello es necesario que tenga interfaces configuradas (IPs) en las redes que quiere comunicar. Tendrá tantas interfaces configuradas como redes a las que esté unido.


\begin{center}
    \vspace{-15pt}
    \includegraphics[width=0.6\linewidth]{router_redes.png}
    \vspace{-5pt}
    \captionof{figure}{Router conectado a 3 redes}
    \vspace{-15pt}
\end{center}

El ejemplo más sencillo de router lo tenemos en casa, que es proporcionado por nuestro ISP. Este router une la red privada donde conectamos nuestros equipos (PCs, tablets, móviles) y la red del proveedor que a su vez nos dará acceso a Internet.


\hypertarget{default_gateway}{}
\subsection{Puerta de enlace predeterminada}
La puerta de enlace predeterminada (en inglés \textit{\textbf{default gateway}}) es el dispositivo por defecto por el que irá la comunicación de un equipo cuando trate de comunicarse con una red que no es la suya.

Sin una puerta de enlace, nuestro PC sólo podría comunicarse con otros equipos de la misma red, ya que el switch se encarga de ello, pero no podríamos realizar ninguna comunicación con ningún equipo que estuviese fuera de la red.

\warnbox{\textbf{Los routers también pueden tener puertas de enlace predeterminadas.}}

Los gateway también tienen otras funciones a la hora de intercomunicar redes, como por ejemplo:
\begin{itemize}
    \item Traducir la información que se envía utilizando el protocolo de la red de origen al protocolo utilizado en la red de destino.
    \item Realizar enmascaramiento de la IP de la red origen cambiándola por la IP del dispositivo en la red de destino (también conocido como \hyperlink{nat}{NAT}).
\end{itemize}

Un equipo sólo podrá contar con una puerta de enlace predeterminada configurada, pero mediante \hyperlink{rutas_estaticas}{rutas estáticas} podremos elegir cómo encaminar tráfico a otras redes destino.

\infobox{\textbf{Un equipo sólo podrá contar con una puerta de enlace predeterminada configurada.}}

Para saber cuál es la puerta de enlace de un equipo informático, dependeremos del sistema operativo en el que nos encontremos. En un entorno GNU/Linux actual podremos obtenerlo por consola de la siguiente manera:

\begin{mycode}{Obtener puerta de enlace en GNU/Linux}{console}{}
ruben@ubuntu:~$ ip route
default via 192.168.1.1 dev enp1s0 proto dhcp metric 100
\end{mycode}

En distribuciones antiguas se hacía
\begin{mycode}{Obtener puerta de enlace en GNU/Linux}{console}{}
ruben@ubuntu:~$ route -n

Kernel IP routing table
Destination     Gateway      Genmask      Flags Metric Ref  Use Iface
0.0.0.0      192.168.1.1     0.0.0.0      UG    100    0    0   enp1s0
\end{mycode}


En un entorno Windows, podremos verlo a través del interfaz gráfico yendo a “\textbf{Configuración → Estado de red → Cambiar opciones del adaptador}”, donde veremos los adaptadores que tiene nuestro equipo. Seleccionaremos uno, y haciendo click derecho le daremos a “\textbf{Estado → Detalles}”

\begin{center}
    \vspace{-15pt}
    \includegraphics[frame,width=0.4\linewidth]{windows_network_status.png}
    \vspace{-15pt}
\end{center}

Para no dar tantos pasos, si ejecutamos en la terminal \textbf{CMD} el siguiente comando también lo veremos:

\begin{mycode}{Obtener puerta de enlace en Windows}{powershell}{}
C:\Users\ruben> ipconfig

Configuración IP de Windows
Adaptador de Ethernet Instancia de Ethernet 0 2:

Sufijo DNS específico para la conexión. . : Home
Vínculo: dirección IPv6 local. . . : fe80::90f1:e72f:5a42:b50d%7
Dirección IPv4. . . . . . . . . . . . . . : 192.168.1.135
Máscara de subred . . . . . . . . . . . . : 255.255.255.0
Puerta de enlace predeterminada . . . . . : 192.168.1.1
\end{mycode}

Pueden existir equipos sin puerta de enlace, pero no suele ser lo habitual. Esto sucede cuando queremos que equipos puedan ver a otros equipos de la red, pero no puedan comunicarse con el exterior. Suele ser más habitual realizar bloqueos a nivel de firewall.

\subsection{Router casero}
\begin{wrapfigure}{l}{0.2\linewidth}
    \centering
    \vspace{-20pt}
    \includegraphics[width=\linewidth]{home_router.png}
    \vspace{-32pt}
\end{wrapfigure}
Los routers caseros son dispositivos que nos permiten conectarnos a internet. El problema es que normalmente suelen ser muy básicos y su funcionalidad es limitada.

Eso no quita que realmente cumpla la función para la que han sido creados, que es la de permitir la interacción de una red como la de un hogar hacia internet.

Los routers caseros suelen tener diferenciada en la parte de atrás el interfaz donde se debe conectar el cable que va hacia Internet (en este caso de color azul) y las bocas que van a formar la red LAN interna de casa (color amarillo), que realmente son un pequeño switch de 4 bocas.

\begin{center}
    \vspace{-15pt}
    \includegraphics[width=0.7\linewidth]{home_router_back.png}
    \vspace{-4pt}
    \captionof{figure}{Home-Router en Packet Tracer}
    \vspace{-15pt}
\end{center}


Dependiendo del tipo de conexión que tangamos en casa, el interfaz que nos conecta a internet será distinto, pudiendo ser hoy día los más habituales:

\begin{itemize}
    \item \textbf{Cable coaxial}: En conexiones con Euskaltel en el que no nos llega la fibra hasta casa.
    \item \textbf{Conector de fibra}: Cuando la fibra nos llega hasta nuestra casa.
\end{itemize}

Los routers que tenemos en casa también tiene otras funcionalidades básicas que vienen pre-configuradas como veremos a continuación, entre las que podemos destacar:

\begin{itemize}
    \item \textbf{Direccionamiento LAN}: Normalmente viene configurado con la red 192.168.1.0/24 o 192.168.1.0/24

    \item \textbf{\hyperlink{dhcp}{DHCP Server}}: Servicio que otorga IPs en nuestra red LAN, teniendo en cuenta el direccionamiento que tengamos.

    \item \textbf{Configuración Wifi}: Dependiendo del modelo tendremos distintas redes inalámbricas (en distintos rangos). Podremos configurar el nombre de la red, el canal y el tipo de seguridad de acceso a la misma.

    \item \textbf{Restricción hacia internet}: Algunos routers permiten limitar el acceso a Internet en ciertos horarios (ideal para restringir el acceso a menores de edad).

    \item \textbf{Redirección de puertos}: Para redirigir conexiones desde Internet a un equipo concreto dentro de la red.

    \item \textbf{Filtrado MAC}: Normalmente para el apartado Wifi, y así limitar quién se puede o no se puede conectar.
\end{itemize}


\subsection{Router profesional}
\begin{wrapfigure}{l}{0.2\linewidth}
    \centering
    \vspace{-20pt}
    \includegraphics[width=\linewidth]{router.png}
    \vspace{-32pt}
\end{wrapfigure}

Los routers profesionales difieren de los routers caseros en que cada interfaz que tienen van a formar parte de una red distinta, y que deberemos de configurar nosotros los servicios que nos interesen ya que no suelen venir pre-configurados.

En Packet Tracer podemos encontrar distintos modelos de routers, pero los que más vamos a utilizar son unos que no existen en la vida real, los denominados “\textbf{PT-Empty}”. Al igual que con los switches, estos routers no cuentan con ninguna interfaz asociada en el momento en el que lo situamos en nuestra simulación, y nos permite añadir hasta diez interfaces que queramos.

Los routers son los dispositivos en capa 3 que se encargan de enrutar tráfico entre distintas redes. Hay que tener claro que puede encaminar tráfico a redes a las que pertenece, o a redes a las que sabría llegar (a través de rutas).

A continuación se van diferenciar distintos apartados básicos en la configuración de los routers.

\subsubsection{Setup}
Al igual que sucede con los switches, los routers cuentan con un comando setup con el que poder realizar una primera configuración. Las preguntas que nos realizará son las mismas que las de los switches.
En este caso, las IPs se configuran en los interfaces físicos que tiene el router.


\subsubsection{Comandos básicos}
En los routers Cisco que vamos a utilizar, los comandos de consola son similares a los que hemos visto con los switches.

\begin{mycode}{Ver la configuración}{powershell}{}
Router# show running-config
\end{mycode}

Siempre que realicemos cualquier tipo de modificación, debemos guardar la configuración para que esta se mantenga en el próximo arranque.

\begin{mycode}{Guardar la configuración}{powershell}{}
Router# copy running-config startup-config
\end{mycode}

La configuración de la IP que queremos que tenga nuestro router irá asociado a un interfaz que esté en contacto con la red. Es importante que no confundamos con lo que sucede en los switches, que en ellos la IP va asociada a la VLAN.

\begin{mycode}{Configurar un interfaz con una IP}{powershell}{}
Router# configure terminal

Router(config)# interface GigabitEthernet0/0

Router(config-if)# ip address 192.168.1.1 255.255.255.0
\end{mycode}

Los interfaces físicos, en los routers por defecto están deshabilitados, por lo que da igual que haya un cable conectado a él. Para que exista enlace se tiene que habilitar:

\begin{mycode}{Habilitar interfaz}{powershell}{}
Router# configure terminal

Router(config)# interface GigabitEthernet0/0

Router(config-if)# no shutdown

\end{mycode}



\hypertarget{nat}{}
\section{NAT}
La traducción de direcciones de red, también llamado enmascaramiento de IP o NAT (del inglés \textit{\textbf{Network Address Translation}}), es un mecanismo utilizado por routers que conectan dos (o más) redes para que el paquete que llega a un equipo destino no parezca que llega desde la red de origen.

Vamos a tomar como ejemplo el siguiente esquema que es un ejemplo que podemos entender teniendo en cuenta la conexión de nuestra casa:

\begin{center}
    \vspace{-15pt}
    \includegraphics[width=0.8\linewidth]{NAT.png}
    \vspace{-25pt}
\end{center}

En este ejemplo tenemos conectado un equipo con IP 192.168.1.15 al router que tenemos en casa (cuya IP en la LAN es 192.168.1.1). Este router cuenta con una IP pública proporcionada por el ISP para el acceso a internet (83.84.1.7). Cuando nuestro equipo quiere comunicarse con algún equipo que no está en su red, al salir a internet, el router cambia la cabecera del paquete sustituyendo 192.168.1.15 por 83.84.1.7, y de esta manera al servidor remoto (212.142.27.34) el paquete le llega desde una IP pública.

Este es el ejemplo más sencillo y que hacemos uso cada día en casa, pero esto no significa que NAT sólo se realice entre redes públicas y privadas. Lo podemos utilizar entre dos redes públicas o dos redes privadas también.

Las traducciones de dirección se almacenan en una tabla, para recordar qué dirección y puerto le corresponde a cada dispositivo cliente y así saber donde deben regresar los paquetes de respuesta.

Existen distintos tipos de NAT:
\begin{itemize}
    \item \textbf{NAT de sobrecarga}: Varios equipos de la red de origen se traducen por una única dirección de la red de salida. Es el método más habitual (el que realizan nuestros routers en casa).

    \item \textbf{NAT estática}: También conocida como “NAT 1:1”, ya que una dirección IP privada se traduce siempre por una única dirección IP pública, y siempre será la misma. Este método es el habitual cuando queremos tener un servidor en la red interna y queremos que su comunicación con el exterior siempre sea con la misma IP pública

    \item \textbf{NAT dinámica}: Similar al caso anterior, pero en este caso el router contará con una tabla de IPs públicas y se asignará una que esté libre de esta tabla a un equipo interno cuando necesite comunicarse de manera pública. Cuando deje de necesitarlo, la IP se marcará como “libre” y se podrá asignar a otro equipo interno posteriormente.
\end{itemize}

\hypertarget{dhcp}{}
\section{DHCP}
El protocolo de configuración dinámica de host (\textit{Dynamic Host Configuration Protocol}, también conocido por sus siglas de \textbf{DHCP}) es un protocolo de red que nos permite configurar la IP de un dispositivo dentro de una red.

Normalmente el protocolo DHCP enviará la configuración de los siguientes parámetros para que el equipo los use:

\begin{itemize}
    \item \textbf{IP}: IP asignada al equipo.
    \item \textbf{Máscara de red}: para identificar el tamaño de la red.
    \item \textbf{\hyperlink{default_gateway}{Default gateway}}: para que el equipo se pueda comunicar con otra red.
    \item \textbf{DNS}: el servidor DNS que utilizará el equipo para la resolución de nombres.
\end{itemize}

\begin{wrapfigure}{r}{0.2\linewidth}
    \centering
    \vspace{-20pt}
    \includegraphics[width=\linewidth]{sesion_DHCP.png}
    \vspace{-32pt}
    \captionof{figure}{\href{https://es.wikipedia.org/wiki/Protocolo\_de\_configuraci\%C3\%B3n\_din\%C3\%A1mica\_de\_host\#DHCP\_Discovery}{Referencia}}
    \vspace{-30pt}
\end{wrapfigure}
Existen muchas más \href{https://es.wikipedia.org/wiki/Par\%C3\%A1metros_DHCP}{configuraciones} que se pueden enviar a un equipo que realiza una petición de configuración por DHCP, pero las arriba expuestas son las más habituales.

El protocolo funciona en forma “Cliente/Servidor”, siendo el equipo el que realiza la búsqueda de un servidor DHCP para el inicio de la configuración. DHCP hace uso de los puertos 67/UDP para el servidor y 68/UDP para los clientes.

Lo más habitual es que el servidor DHCP esté configurado en los routers (tal como sucede en los que nos proporcionan los ISP), pero no tiene por qué ser así, pudiendose instalar en un equipo con Windows Server, GNU/Linux, ...

\subsection{Configuración}
Dependiendo del equipo en el que estemos realizando la configuración del servidor DHCP, el interfaz a configurar podrá ser distinto.


\subsubsection{Router Casero}
En la simulación de los \textit{Home-Router} que tiene Packet Tracer, el interfaz es el real que tenían los míticos \href{https://es.wikipedia.org/wiki/WRT54G}{Linksys WRT54G}, siendo la configuración del DHCP la siguiente:

\begin{center}
    \vspace{-15pt}
    \includegraphics[frame,width=0.8\linewidth]{dhcp_home_router.png}
    \vspace{-15pt}
\end{center}

\subsubsection{Servidores}
En los servidores de Packet Tracer podemos realizar la configuración de un servidor DHCP en el siguiente interfaz:

\begin{center}
    \vspace{-15pt}
    \includegraphics[width=0.8\linewidth]{dhcp_servidor.png}
    \vspace{-15pt}
\end{center}


\subsubsection{Router profesional}
Aunque algunos routers Cisco profesionales cuentan con un interfaz web de configuración, es recomendable conocer los comandos para realizar la configuración a través del \textit{\textbf{CLI}}.

Vamos a suponer que el router que tenemos que configurar cuenta con dos interfaces cuyas IPs son \textbf{192.168.1.1 /24} y \textbf{172.16.0.1 /22}.

\begin{mycode}{Configurar DHCP para la primera red}{powershell}{}
Router(config)# ip dhcp excluded-address 192.168.1.1
Router(config)# ip dhcp pool lan
Router(dhcp-config)# network 192.168.1.0 255.255.255.0
Router(dhcp-config)# default-router 192.168.1.1
Router(dhcp-config)# dns-server 8.8.8.8
\end{mycode}

\begin{mycode}{Configurar DHCP para la segunda red}{powershell}{}
Router(config)# ip dhcp excluded-address 172.16.0.1
Router(config)# ip dhcp pool alumnos
Router(dhcp-config)# network 172.16.0.0 255.255.252.0
Router(dhcp-config)# default-router 172.16.0.1
Router(dhcp-config)# dns-server 8.8.8.8
\end{mycode}



\section{Encaminamiento de tráfico a otras redes}
Tal como hemos dicho, un router se encarga de encaminar el tráfico entre redes, ya sean redes a las que esté directamente conectado o no. En caso de que sea un paquete a una red ajena, existen distintas maneras de tratarlo:

\begin{itemize}
    \item Reenviar el tráfico a la puerta de enlace predeterminada.
    \item Consultar la tabla de enrutamiento (o tabla de rutas).
\end{itemize}

La tabla de enrutamiento se almacena en los routers y nos indicará cómo llegar a nodos u otras redes a las que no tenemos acceso de manera directa. La tabla de enrutamiento se puede genera haciendo uso de:

\begin{itemize}
    \item \textbf{Rutas estáticas}: deben ser introducidas a mano.
    \item \textbf{Rutas dinámicas}: mediante un protocolo de enrutamiento dinámico.
\end{itemize}


\hypertarget{rutas_estaticas}{}
\subsection{Rutas estáticas}
Las rutas estáticas sirven para obligar a los paquetes, cuyo destino coincide con la ruta, a ir a través de la puerta de enlace especificada, en lugar de ir por la puerta de enlace predeterminada. Lógicamente, para que esto suceda, la puerta de enlace tiene que ser alcanzable por el router, por lo que tenemos que tener acceso a través de la misma red.


La ruta estática se configura para conseguir conectividad con un dispositivo que no esté directamente conectado al equipo que tenga las rutas. Las rutas estáticas permiten la construcción manual de la tabla de enrutamiento.

\begin{center}
    \vspace{-15pt}
    \includegraphics[width=0.8\linewidth]{rutas_estaticas.png}
    \vspace{-25pt}
\end{center}

Teniendo en cuenta el dibujo, para que un equipo de la red 1 pueda comunicarse con un equipo de la red 2 el tráfico debe ser enrutado por el router R1. En este caso, el router R1 no tiene conexión directa con la red 2, pero tiene una ruta estática que para poder llegar a la red 2 le puede redirigir el tráfico al router R2 a través de la IP2 (que está en la misma red que la IP1).

Para que la conectividad funcione, es necesario configurar la ruta en ambas direcciones. Es decir, para que la comunicación vuelva, el router R2 también tendrá que tener a su vez una ruta estática para llegar a la Red1 yendo a través del router R1.



\subsubsection{Rutas estáticas con distancia administrativa}
En algunas arquitecturas de red, puede existir la posibilidad de llegar a una misma red a través de dos rutas. En estos casos, debemos priorizar una de las rutas, quedando la otra como secundaria y que sólo será utilizada en caso de que la primera ruta falle.

Tomemos como ejemplo la siguiente arquitectura:

\begin{center}
    \vspace{-15pt}
    \includegraphics[width=0.8\linewidth]{rutas_estaticas_distancia.png}
    \vspace{-25pt}
\end{center}

Para que la red 1 se pueda comunicar con la red 2 el router R1 puede ir por dos caminos distintos. En este caso, las rutas estáticas a crear serían:
\begin{itemize}
    \item \textbf{Ruta principal}: priorizamos el tráfico por R2, a través de la IP3.
    \item \textbf{Ruta menos prioritaria}: en caso de falla la anterior ruta, el router R1 enviará el tráfico por router R3 llegando a él por la IP4.
\end{itemize}

En este caso, a las rutas menos prioritarias se les añade una “distancia administrativa” (a veces también llamado “peso”). Esta distancia es un número entero que indicará la prioridad (cuanto mayor el número, menor la prioridad).

\subsubsection{Ejemplos}

La creación de rutas estáticas se realiza con \commandbox{ip route RED  MÁSCARA  SALTO} siendo:
\begin{itemize}
    \item \textbf{ip config}: el comando que indica que vamos a crear una ruta.
    \item \textbf{RED}: la  red a la que queremos llegar.
    \item \textbf{MÁSCARA}: Máscara de la red a la que queremos llegar
    \item \textbf{SALTO}: IP del dispositivo a través del cual queremos llegar a la red indicada anteriormente.  Este dispositivo tiene que estar en nuestra misma red y tenemos que poder llegar a él.
\end{itemize}

Por lo tanto, un ejemplo real podría ser:


\begin{mycode}{Crear ruta estática para una red}{powershell}{}
Router(config)# ip route 172.20.10.0  255.255.252.0  10.0.0.2
\end{mycode}

También podemos realizar rutas estáticas sólo para una IP, siendo la máscara /32 en decimal:

\begin{mycode}{Crear ruta estática para un equipo}{powershell}{}
Router(config)# ip route 172.20.10.25  255.255.255.255  10.0.0.3
\end{mycode}

Cuando hay rutas distintas para una IP y una red, se prioriza de lo más específico a lo más genérico. Por lo tanto, se prioriza la ruta de una IP, aunque se indique que para toda la red haya que ir por otro salto.


\paragraph{Crear ruta estática con “distancia administrativa”}
A la hora de crear una ruta estática con “distancia administrativa”, se realiza de la misma forma que acabamos de ver, pero añadiendo al final la distancia administrativa de la ruta, siendo un número entero. Este “peso” es utilizado cuando en la tabla de rutas existen dos rutas para llegar al mismo destino por caminos diferentes, por lo que se priorizará la ruta con el número más pequeño (o que no tenga número).

\begin{mycode}{Crear ruta estática y ruta con distancia administrativa}{powershell}{}
Router(config)# ip route 172.20.10.0  255.255.252.0  10.0.0.2

Router(config)# ip route 172.20.10.0  255.255.252.0  192.168.1.1  10
\end{mycode}

Como se puede ver, para llegar al mismo destino (172.20.10.0 /22) podemos elegir dos saltos por los que llegar: 10.0.0.2 y 192.168.1.1. La ruta que tenga menor distancia administrativa será la predeterminada, y por tanto los paquetes se irán por ella.


\subsection{Enrutamiento dinámico}

El enrutamiento dinámico permite a los encaminadores ajustar, en tiempo real, los caminos utilizados para transmitir paquetes IP. Cada protocolo posee sus propios métodos para definir rutas (camino más corto, utilizar rutas publicadas por pares, etc.).


\subsubsection{BGP (Border Gateway Protocol)}
El protocolo BGP (en castellano protocolo de “Puerta de Enlace de Frontera”) es un protocolo mediante el cual \textbf{se intercambia información de encaminamiento entre sistemas autónomos}.

%TODO: poner un dibujo de cómo es una red con BGP

Un \textbf{Sistema Autónomo} (o \textbf{AS}, de \textit{Autonomous System}) es un grupo de redes IP controladas por una misma compañía (normalmente un proveedor de internet ISP, o una gran compañía) que son gestionadas de manera independiente y realiza su propia gestión del tráfico. Los sistemas autónomos cuentan con un número (\textbf{ASN}) de 16 o 32 bits que debe ser respetado, ya que al igual que las IPs, existen ASN públicos y privados. En la wikipedia aparece una \href{https://es.wikipedia.org/wiki/Sistema_aut%C3%B3nomo#Tabla_con_ASN_de_16-bit_y_32-bit}{lista de estos rangos}.

El intercambio de esos rangos de IPs se realiza en los denominados “router frontera” o “router externos”, que son los que están comunicados con otros routers de otros AS. Estos routers son los encargados de \textbf{anunciar} las propias redes del AS a sus “vecinos” (neighbors en inglés), que a su vez propagarán esa información a sus propios vecinos ...

Si un AS decide anunciar una nueva red, automáticamente sus vecinos son actualizados, que a su vez propagan la actualización. Si un router recibe su propia actualización, la rechaza.

\errorbox{\textbf{Es importante que un router no anuncie redes IP que no le pertenecen.}}

En la \href{https://en.wikipedia.org/wiki/BGP_hijacking}{wikipedia} aparecen distintos incidentes por errores en la propagación de rutas.
Cuando un router propaga una red (ya sea suya o de otro AS) añade su ASN, y de esta manera se conoce para llegar a una ruta por cuántos AS se pasan (pero no por cuántos routers internos).

Hoy en día Internet funciona con el protocolo BGP y actualmente el protocolo anuncia más de 900.000 rutas (\href{https://blog.apnic.net/2022/01/06/bgp-in-2021-the-bgp-table/}{fuente}):

\begin{center}
    \vspace{-15pt}
    \includegraphics[width=0.8\linewidth]{bgpfig4-1024x608.png}
    \vspace{-25pt}
\end{center}


\subsubsection{Ejemplos}
En los routers debemos crear la configuración para que se convierta en un “\textit{Autonomous System}” (AS, Sistema Autónomo).

\begin{mycode}{Crear sistema autónomo}{powershell}{}
Router(config)# router bgp 100
\end{mycode}

Una vez dentro del sistema autónomo, habrá que indicar qué red se quiere propagar a los “vecinos”:

\begin{mycode}{Anunciar red a propagar}{powershell}{}
Router(config-router)# network 192.168.1.0 mask 255.255.255.0
\end{mycode}

Para poder propagar la red, debemos indicar a qué vecinos se los vamos a propagar:

\begin{mycode}{Vecinos a los que propagar la red}{powershell}{}
Router(config-router)# neighbor 10.10.2.1 remote-as 200
\end{mycode}

Para conocer el estado de las rutas BGP podemos realizar:

\begin{mycode}{Comprobar estado de BGP}{powershell}{}
Router#show ip bgp
BGP table version is 6, local router ID is 192.168.1.1
Status codes: s suppressed, d damped, h history, * valid, > best,
              i - internal, r RIB-failure, S Stale

Origin codes: i - IGP, e - EGP, ? - incomplete

Network               Next Hop           Metric LocPrf  Weight  Path
*> 192.168.1.0/24      0.0.0.0                0     0    32768       i
*> 192.168.2.0/24    10.10.2.1                0     0        0   200 i
\end{mycode}

\subsection{Tabla de rutas completa}
Los routers Cisco tienen una opción que nos muestra todas las rutas a las que el router puede acceder:

\begin{mycode}{Comprobar estado de BGP}{powershell}{{\small}}
Router# show ip route
Codes: C - connected, S - static, I - IGRP, R - RIP, M - mobile, B - BGP
    D - EIGRP, EX - EIGRP external, O - OSPF, IA - OSPF inter area
    N1 - OSPF NSSA external type 1, N2 - OSPF NSSA external type 2
    E1 - OSPF external type 1, E2 - OSPF external type 2, E - EGP
    i - IS-IS, L1 - IS-IS level-1, L2 - IS-IS level-2, ia - IS-IS inter area
    * - candidate default, U - per-user static route, o - ODR
    P - periodic downloaded static route

Gateway of last resort is not set

        8.0.0.0/25 is subnetted, 1 subnets
C       8.8.8.0 is directly connected, GigabitEthernet1/0

        10.0.0.0/30 is subnetted, 1 subnets
C       10.10.0.0 is directly connected, GigabitEthernet2/0

        83.0.0.0/27 is subnetted, 1 subnets
C       83.85.67.0 is directly connected, GigabitEthernet0/0

        95.0.0.0/26 is subnetted, 1 subnets
B       95.94.32.0 [20/0] via 10.10.0.2, 00:00:00

        212.140.23.0/28 is subnetted, 1 subnets
S       212.140.23.16 [1/0] via 83.85.67.4
\end{mycode}

Tal como aparece justo después del comando, hay unos códigos que nos indican si los rangos son:
\begin{itemize}
    \item[\textbf{B:}] Red que podemos llegar mediante el protocolo BGP.
    \item[\textbf{C:}] Red a la que estamos directamente conectados a través de un interfaz físico.
    \item[\textbf{S:}] Red a la que podemos llegar siendo una ruta estática.
\end{itemize}



\chapter{Redes virtuales}
Es habitual querer diferenciar distintas redes dentro de una arquitectura de red (para diferenciar departamentos en una empresa, separar servidores de equipos de trabajo, limitar el acceso entre redes, ...) pero eso supone la compra de distintos equipamientos físicos (distintos switches, puntos de acceso ...) que incrementa el coste de nuestra infraestructura.

Para evitar este incremento de precio, podemos hacer uso de las \textbf{VLAN} en nuestros dispositivos de red, ya sea en switches o en routers, que los soporten.

\section{VLAN}
Una VLAN, acrónimo de \textit{virtual LAN} (red de área local virtual), \textbf{es un método para crear redes lógicas independientes dentro de una misma red física}. Varias VLAN pueden coexistir en un único switch físico o en una única red física, y el tráfico estará separado entre distintas VLANs a nivel lógico.

Un equipo de una VLAN no se podrá comunicar con otro equipo de otra VLAN distinta salvo que haya un router que esté conectado en ambas VLANs y que encamine el tráfico de una a la otra. Lo mismo que si fuesen dos redes físicas, como hemos visto hasta ahora.

Las VLANs se diferencian a través de una cabecera extra la cual se añade dentro del encabezado original de la trama (\textbf{capa 2}). Esa cabecera consta de dos partes de 16 bits, siendo los últimos 12 los que correspondan al valor que identificará a la VLAN, y estará comprendido entre 1 y 4095, ya que el 0 está reservado. Esa cabecera indicará que el tráfico está etiquetado o “\textit{\textbf{tagged}}”.

\infobox{Las VLANs se diferencian a través de una cabecera extra la cual se añade dentro del encabezado original de la trama (\textbf{capa 2}).}

A continuación se puede ver cómo se muestra tráfico etiquetado mediante las cabeceras del \textbf{protocolo 802.1Q}:

\begin{center}
    \vspace{-10pt}
    \includegraphics[frame,width=0.9\linewidth]{vlan-tag.png}
    \vspace{-10pt}
\end{center}

\begin{itemize}
    \item \textbf{TPID}: 16 bits en el que el valor  “\textbf{0x8100}” indica que es una trama etiquetada del protocolo \textbf{802.1Q}.
    \item \textbf{TCI}: 16 bits (formando 4 caracteres en hexadecimal):
    \begin{itemize}
        \item \textbf{PCP}: 3 bits que permiten priorizar el tráfico.
        \item \textbf{DEI}: 1 bit, en conjunto con PCP, que permite saber si esta trama se puede descartar en caso de congestión.
        \item \textbf{VID}: \textit{VLAN IDentificator}, 12 bits ($2^{12} = 4096$). En este caso los últimos 3 caracteres hexadecimales “00A” que indica que es la VLAN 10.
    \end{itemize}
\end{itemize}

Hay que tener en cuenta que aunque existe el límite de 4096 VLANs, algunos switches tienen una limitación de un número menor de VLANs activas. Es decir, puedes crear VLANs con el dígito que quieras (hasta 4095), pero quizá sólo te dejan crear 16 VLANs. Ejemplo de la limitación del número de VLANs que puede haber activas en switches “\href{https://www.cisco.com/c/dam/en/us/products/collateral/switches/small-business-100-series-unmanaged-switches/data_sheet_c78-634369_Spanish.pdf}{Cisco de la serie 200 Cisco Small Business}”:

\begin{tblr}{X[2cm] X}
    VLAN & Compatibilidad con hasta \textbf{256 VLAN simultáneas} (de 4096 ID de VLAN). \textbf{16 VLAN compatibles en SG200-08 y SG200-08P}.

    VLAN basadas en puertos y en etiquetas 802.1Q \\

    VLAN de voz & El tráfico de voz se asigna automáticamente a una VLAN específica de voz y se trata con los niveles apropiados de QoS \\
\end{tblr}

Como se puede apreciar, en este modelo de Switch, el límite es de 256 VLAN activas (aunque se puede elegir el ID de la VLAN de las 4096 posibles), y de “sólo” 16 VLANs en el modelo de 8 bocas ethernet de esa serie.


\subsection{Diferencia de arquitecturas con y sin VLANs}
Para que quede más claro lo explicado hasta ahora, vamos a analizar una misma infraestructura de red separada a nivel físico y separada a nivel lógico mediante VLANs.

\subsubsection{Arquitectura sin VLAN}
En una arquitectura de red sin VLANs tendríamos que tener tantos switches como sean necesarios para realizar una separación física de las redes. Estos switches estarán conectados a un router que será el encargado de encaminar el tráfico entre las redes. La separación física de redes es más cara ya que se necesita más hardware y es posible que los switches estén infrautilizados.

\begin{center}
    \vspace{-15pt}
    \includegraphics[width=0.8\linewidth]{red-sin-vlan.png}
    \vspace{-15pt}
\end{center}

Se puede observar una arquitectura en la que un router actúa de intermediación en una red en la que existen 4 redes separadas físicamente mediante distintos switches. Si en una red existen pocos dispositivos, el switch de esa red estará infrautilizado. Si por el contrario necesitamos ampliar alguna de las redes, deberemos añadirle un switch en cascada en la red correspondiente, pero aún así ese nuevo switch podría estar infrautilizado.


\subsubsection{Arquitectura con VLANs}

En una arquitectura con \textbf{VLAN}s, tendremos un router que estará conectado a un switch mediante un enlace \hyperlink{puerto_trunk}{trunk}, y en este switch se configurará cada interfaz en modo \hyperlink{puerto_access}{access} teniendo en cuenta el dispositivo que se vaya a conectar a dicha interfaz. En caso de necesitar ampliar las redes, se hará uso de las interfaces no utilizadas, y en caso de no haber más, el switch se podría expandir añadiendo uno nuevo y \hyperlink{stack_switches}{creando un stack} entre ellos.

\begin{center}
    \vspace{-15pt}
    \includegraphics[width=0.8\linewidth]{red-con-vlan.png}
    \vspace{-15pt}
\end{center}

\section{VLANs en Switches}

En los switches se pueden realizar distintas configuraciones teniendo en cuenta las VLANs que vayamos a utilizar y la arquitectura de red que tengamos:

\begin{itemize}
    \item \textbf{VLAN por defecto en el switch}: Es la VLAN en la que trabajará el switch. Por defecto suele ser la \textbf{VLAN 1}. El tráfico por defecto va en esa VLAN y para ir por cualquier otra VLAN el tráfico deberá estar “\textit{tagged}” (etiquetado).

    \hypertarget{puerto_trunk}{}
    \item \textbf{Puerto en modo “\textit{trunk}”}: Normalmente utilizado para comunicación entre distintos switches y/o routers. A este enlace “\textbf{\textit{trunk}}” (o troncal, o tronco) se le asigna una VLAN por defecto y las VLANs “\textbf{tagged}” permitidas que pasarán por él. Los switches sabrán a qué VLAN pertenece cada trama observando la etiqueta VLAN de la capa 2.

    El tráfico que \textbf{entra} en esta boca, si no está etiquetado estará en la VLAN por defecto. Si está etiquetado en una VLAN permitida se permitirá el tráfico.

    El tráfico que \textbf{sale} de esta boca saldrá de la misma manera con la que llegó a él (sin etiquetar o etiquetado con la VLAN que sea). El equipo que reciba esta trama tendrá que lidiar con el tráfico recibido (ya sea etiquetado o no).

    \hypertarget{puerto_access}{}
    \item \textbf{Puerto en modo “\textit{access}”}: La boca del switch se define en modo “access” (o “acceso”) y se le asigna una \textbf{única VLAN} a la misma.

    Este tipo de configuraciones suele ser utilizada para conectar equipos en los que no podemos etiquetar VLANs en origen (impresoras por ejemplo), o nos resulte tedioso la configuración de la misma, pero queremos asegurar que su tráfico viaje por una VLAN.

    El \textbf{tráfico que entra} en esta boca, a partir de ese momento \textbf{se le añadirá la cabecera de la VLAN a la trama} convirtiéndose en tráfico “tagged”.

    Si el \textbf{tráfico sale} de una boca en modo “access” se quitará la cabecera VLAN, por lo que \textbf{al equipo remoto le llegará el tráfico sin estar “tagged”}.

\end{itemize}

Teniendo en cuenta lo explicado previamente, se puede observar en el siguiente dibujo en el que aparecen varios switches, configurados con distintas bocas en modo \textbf{access} y otras en modo \textbf{trunk}. Como se puede ver, las bocas que comunican los distintos dispositivos (switches con switches y switch con router) están configuradas en modo TRUNK, y en ellas se permiten varias VLANs.

Las interfaces que sólo tienen un color, están configuradas en modo \textbf{access} con una VLAN. Los interfaces en blanco no están configurados (ya que usan la VLAN por defecto, en este caso la VLAN 1). Para que el router pueda enrutar las distintas redes, le tendrán que llegar a través de un enlace configurado en modo \textbf{trunk}.
\textbf{}

\begin{center}
    \vspace{-10pt}
    \includegraphics[width=0.9\linewidth]{switch_configuracion_access_trunk.png}
    \vspace{-10pt}
\end{center}


\subsection{Crear VLAN}
Para crear una VLAN primero deberemos identificar el identificador, y luego suele ser recomendable darle un nombre identificativo.

\begin{mycode}{Crear VLAN}{powershell}{}
Switch(config)# vlan 10
Switch(config-vlan)# name Profesores
\end{mycode}

\subsection{Añadir IP en una VLAN}
En caso de necesitarlo, se podrá añadir una IP a cada nueva vlan que se haya creado, tal como se hace con la VLAN 1, pero eligiendo la VLAN correspondiente.

\begin{mycode}{Añadir IP a la VLAN}{powershell}{}
switch(config)# interface vlan10
switch(config-if)# ip address 10.10.0.254 255.255.255.0
switch(config-if)# no shutdown
\end{mycode}

\subsection{Listar tabla de VLAN}
El siguiente comando nos muestra la base de datos interna de VLANs que tiene el switch, indicando el estado y un pequeño resumen de en qué bocas está activa. Hay que tener en cuenta que no nos indica en qué modo está configurada dicha VLAN en cada interfaz, por lo que deberemos comprobarlo mirando detalladamente la configuración completa.

\begin{mycode}{Listar la tabla de VLAN}{powershell}{}
Switch# show vlan

VLAN    Name            Status    Ports
---- ------------------ --------- --------
1    default            active    Gig1/1
10   profesores         active    Gig0/1
20   alumnos            active
...
\end{mycode}

También hay que tener en cuenta que aunque un interfaz esté configurado con una VLAN, si no aparece en la base de datos, es como si no existiese.

\subsection{Configurar interfaz con VLAN en acceso}
Para configurar un interfaz en modo \textbf{\textit{access}} tendremos que elegir primero el interfaz y después elegir el modo a configurar y para qué VLAN. Es importante haber creado primero la VLAN.
\begin{mycode}{Configurar interfaz en modo trunk}{powershell}{}
Switch(config)# interface GigabitEthernet 0/1
Switch(config-if)# switchport mode access
Switch(config-if)# switchport access vlan 10
\end{mycode}


\subsection{Configurar interfaz con VLAN en trunk}
Para configurar un interfaz en modo \textbf{\textit{trunk}} tendremos que elegir primero el interfaz y después elegir el método de configuración:

\begin{mycode}{Configurar interfaz en modo trunk}{powershell}{}
Switch (config)# interface GigabitEthernet 1/1
Switch(config-if)# switchport mode trunk
Switch(config-if)# switchport trunk allowed vlan  ???
\end{mycode}

Donde “???” pueden ser varias opciones:
\begin{itemize}
    \item \textbf{add}: add VLANs to the current list
    \item \textbf{all}: all VLANs
    \item \textbf{except}: all VLANs except the following
    \item \textbf{none}: no VLANs
    \item \textbf{remove}: remove VLANs from the current list
\end{itemize}
Podemos poner la VLAN por defecto en una boca en modo trunk con:

\begin{mycode}{Poner vlan por defecto en un trunk}{powershell}{}
Switch(config-if)# switchport trunk native vlan 10
\end{mycode}


\subsection{VLANs en Routers}
En los routers, las VLANs van asociadas a una interfaz física. Al añadir una VLAN, se crea una interfaz “virtual”, y dentro se le indica que va a ser de tipo “\textbf{encapsulation dot1Q}” y la VLAN que va a usar. Después, se le configura la IP como si fuera una interfaz normal. Como ejemplo para la VLAN 20:

\begin{mycode}{Crear VLAN 20 en Router y configurar una IP}{powershell}{}
Router(config)# interface GigabitEthernet0/0.20
Router(config-if)# encapsulation dot1Q 20
Router(config-if)# ip address 192.168.20.1 255.255.255.0
\end{mycode}




\subsection{VLANs en servidores/ordenadores}
El tráfico que “sale” de un servidor/ordenador, por defecto, no está etiquetado con ninguna VLAN. En caso de que queramos que el tráfico saliente salga con una VLAN etiquetada, tendremos que configurar el interfaz de red para que funcione con dicha VLAN.



\section{Protocolo VTP}
VTP, o \textbf{VLAN Trunk Protocol}, es un protocolo que nos permite configurar y administrar VLANs en equipos Cisco de manera centralizada. De esta manera conseguimos simplificar la tarea cuando tenemos una red en la que disponemos de muchas VLANs

El protocolo funciona en modo  servidor-cliente, por lo tanto debemos configurar un switch en modo servidor, que será en el que realizaremos la administración de las VLANs, que posteriormente serán propagadas por los switches que son clientes VTP y que pertenecen al mismo dominio.


\warnbox{La conexión entre switches debe estar en modo \textbf{trunk} para que el protocolo funcione de manera correcta.}

\subsection{Configurar switch como VTP Server}
Es tan fácil como elegir el modo servidor del protocolo VTP, indicar un dominio de propagación y una contraseña para el mismo.

\begin{mycode}{Crear configuración como VTP Server}{powershell}{}
Switch(config)# vtp mode server
Switch(config)# vtp domain instituto
Switch(config)# vtp password 1234
\end{mycode}

\subsection{Configurar switch como VTP Client}
Similar al caso anterior, pero esta vez eligiendo que queremos que el switch sea cliente:

\begin{mycode}{Crear configuración como VTP Client}{powershell}{}
    Switch(config)# vtp mode client
    Switch(config)# vtp domain instituto
    Switch(config)# vtp password 1234
\end{mycode}

\subsection{Ver estado de VTP}
Para comprobar el estado del servicio VTP, tanto en un switch que sea \textit{server} o \textit{client}:

\begin{mycode}{Ver configuración de estado de VTP}{powershell}{{\small}}
Switch# show vtp status

VTP Version                     : 2
Configuration Revision          : 2
Maximum VLANs supported locally : 255
Number of existing VLANs        : 7
VTP Operating Mode              : Server
VTP Domain Name                 : instituto
VTP Pruning Mode                : Disabled
VTP V2 Mode                     : Disabled
VTP Traps Generation            : Disabled
MD5 digest                      : 0x68 0x70 0x3B 0xF0 0x14 0xC8 0xF7 0xE9
Configuration last modified by 0.0.0.0 at 3-1-93 00:11:38
Local updater ID is 0.0.0.0 (no valid interface found)
\end{mycode}

Y nos ofrece un resumen del estado del mismo.



\chapter{Alta Disponibilidad en sistemas de red}
La \hyperlink{altadisponibilidad}{Alta Disponibilidad} en una arquitectura de red es vital si queremos asegurar el acceso a otras redes o servicios. Para ello podemos hacer uso de distintas tecnologías que nos ayudarán a conseguirlo.



\section{Agregación de enlaces: Etherchannel / LACP}
La agregación de enlaces consiste en combinar (agregar) varias conexiones en paralelo para aumentar el \textit{\textbf{throughput}} (la tasa de transferencia) que conseguiría una única conexión. Un grupo de agregación de enlaces (\textbf{LAG}, de \textit{Link Aggregation Group}) combina una serie de puertos físicos de manera que se consigue una única ruta con más ancho de banda que un único enlace.

A lo largo de los años ha habido distintos estándares para la creación de agregación de enlaces. El último es el conocido como \textbf{LACP} (\textit{Link Aggregation Control Protocol}), que provee un método para controlar la unión de varios puertos físicos formando un único canal lógico. LACP permite negociar automáticamente la unión entre dispositivos mediante el envío de paquetes LACP al otro dispositivo.
LACP permite el modo:

\begin{itemize}
    \item \textbf{activo}: Habilita LACP de manera incondicional. Esto puede hacer que si en las bocas que están habilitadas en modo LACP se conecta algo que no está configurado para ello, no funcione de manera correcta
    \item \textbf{pasivo}: Habilita LACP sólamente cuando se detecta un dispositivo configurado con LACP
\end{itemize}

Como ya se ha comentado, la finalidad es la de unir distintas conexiones para aumentar la tasa de transferencia, y esto no sólo se puede realizar entre switches, si no que también se puede realizar entre un switch y un servidor.

A continuación podemos ver cómo sería un sistema LACP entre dos switches.

\begin{center}
    \vspace{-10pt}
    \includegraphics[width=0.7\linewidth]{LACP-switches.png}
    \vspace{-10pt}
\end{center}

Y aquí podemos ver cómo sería una agregación de enlaces entre un switch y un servidor (ya que en un servidor también podemos realizar la agregación de enlaces).

\begin{center}
    \vspace{-10pt}
    \includegraphics[width=0.6\linewidth]{LACP-switch-server.png}
    \vspace{-10pt}
\end{center}


\subsection{Configurar Etherchannel en Switches}
Antes de realizar ninguna configuración, debemos pensar qué interfaces queremos combinar en una agregación formada por el protocolo LACP.

Para realizar la configuración, deberemos entrar en cada interfaz y añadirlo a un channel-group (siendo el identificador entre el número 1 y el 6) y activar el protocolo a usar:


\begin{mycode}{Añadir interfaces a un \textbf{LAG}}{powershell}{}
Switch(config-if)# channel-group 1 mode active
Switch(config-if)# channel-protocol lacp
\end{mycode}

Cuando se crea un grupo de agregación de enlaces se crea un nuevo interfaz llamado “\textbf{Port-Channel}” (abreviado como “\textbf{Po}”). Es decir, si hacemos la agregación de enlaces con las bocas “0/1” y “1/1” del switch para generar un “channel-group 1”, el switch generará una boca nueva llamada “Port-Channel 1”, la cual podrá ser configurada para hacer lo que necesitemos. En Packet Tracer se pueden tener hasta 6 port-channels:

\begin{mycode}{Configurar Port-Channel 1 en modo \textbf{trunk}}{powershell}{}
switch(config)# interface Port-Channel 1
switch(config-if)# switchport mode trunk
\end{mycode}


Para poder ver el estado del etherchannel/agregación de enlaces:

\begin{mycode}{Ver el estado de los etherchannels}{powershell}{}
Switch# show etherchannel summary

Flags:  D - down        P - in port-channel
I - stand-alone s - suspended
H - Hot-standby (LACP only)
R - Layer3      S - Layer2
U - in use      f - failed to allocate aggregator
u - unsuitable for bundling
w - waiting to be aggregated
d - default port

Number of channel-groups in use: 2
Number of aggregators:           2

Group  Port-channel   Protocol   Ports
------+-------------+-----------+--------------------
1      Po1(SU)           LACP     Gig0/1(P) Gig1/1(P)
2      Po2(SU)           LACP     Gig2/1(P) Gig3/1(P)
\end{mycode}

En este ejemplo, el switch tiene dos agregaciones de enlaces creadas, dos port-channels:
\begin{itemize}
    \item \textbf{Po1}: Tiene configurados los interfaces: Gig 0/1 y Gig 1/1.
    \item \textbf{Po2}: Tiene configurados los interfaces: Gig 2/1 y Gig 3/1.
\end{itemize}

\warnbox{Cada interfaz de cada agregación de enlaces tiene que aparecer con un “\textbf{(P)}”.
    Eso significa que pertenece al port-channel y está correcto.
}


\hypertarget{stack_switches}{}
\section{Stack de switches}

\begin{wrapfigure}{r}{0.36\linewidth}
    \centering
    \vspace{-40pt}
    \includegraphics[width=\linewidth]{stack_fisico.png}
    \vspace{-32pt}
    \captionof{figure}{Stack mediante cables especiales}
    \vspace{-30pt}
\end{wrapfigure}
De manera resumida, es la configuración aplicada a varios switches para que actúen como uno sólo. Esto se realiza mediante la interconexión de los switches (formando un anillo) a través de unos puertos especiales o unas conexiones habilitadas para ello.

Tras la realización del “stackado” de switches las ventajas que obtendremos son muy significativas:

\begin{itemize}
    \item Podremos configurar todas las bocas del conjunto de todos los switches que lo forman desde un único punto central (ya sea mediante el CLI o mediante la web de gestión).
    \item Tendremos redundancia en las comunicaciones.
    \item Permite escalar el tamaño de las comunicaciones y podríamos añadir más switches en un momento dado (algunas marcas permiten 12 switches en un mismo stack).
\end{itemize}

Hay que tener en cuenta que no todos los switches permiten realizar un stack de switches, por lo que tendríamos que asegurarnos que si vamos a necesitar esta funcionalidad, a la hora de comprar los switches lo soporten.

\begin{center}
    \vspace{-10pt}
    \includegraphics[frame,trim={5 255 572 75},clip,width=0.6\linewidth]{stack_cisco.jpg}
    \vspace{-10pt}
\end{center}


\subsection{Integración de Stack y LACP}
Si realizamos la combinación de configuraciones de Stack de switches junto con LACP con servidores, nos aseguraremos de tener una Alta Disponibilidad real en lo que se refiere a comunicaciones.

Veamos el siguiente dibujo:


\begin{center}
    \vspace{-10pt}
    \includegraphics[width=0.6\linewidth]{LACP_stack_servidor.png}
    \vspace{-10pt}
\end{center}

Podemos observar cómo tenemos un stack de 3 switches, que como ya hemos visto previamente actúan como si se tratara de uno sólo. Por otro lado tenemos el servidor, que cuenta con 3 tarjetas ethernet que han sido configuradas a nivel de sistema operativo en modo LACP, y cada una de ellas se ha conectado a un switch distinto del stack.

\infobox{Con esta configuración, nos estamos asegurando que si un switch se estropea, la conectividad seguirá existiendo entre el servidor y el stack a través de los dos enlaces restantes.}

Es muy importante que nuestra infraestructura de red sea pensada para tener el menor número puntos de fallos posibles, y haciendo uso de stacks de switches y conexiones LACP podremos reducir esos puntos de fallo.


\chapter{Seguridad en red}
Tal como hemos visto hasta ahora, una red es una infraestructura compleja utilizada por dispositivos que nos permiten intercambiar información entre equipos y/o usuarios. Para asegurar que el acceso a esa información sólo se realiza desde los dispositivos autorizados, debemos realizar configuraciones de seguridad.

Normalmente, para limitar el acceso a los equipos se hace uso de \textbf{cortafuegos} (también conocidos como \textbf{\textit{Firewalls}}). Estos sistemas cortafuego se pueden implementar de las siguientes maneras:

\begin{itemize}
    \item \textbf{Cortafuegos de red}: Normalmente es un dispositivo \textit{hardware} (que puede ser el mismo router) que actúa como filtrador de paquetes entre las distintas redes que tiene configurado.

    De esta manera, podemos limitar el acceso teniendo en cuenta el origen, destino, puerto y/o protocolo de comunicación utilizado en la comunicación.

    Algunos ejemplos:
    \begin{itemize}
        \item Routers caseros: tienen un sistema de cortafuegos básico.
        \item Routers hardware Cisco.
        \item \hyperlink{pfsense}{pfSense}: una distribución basada en FreeBSD que actúa como firewall.
    \end{itemize}

    \item \textbf{Cortafuegos en el equipo}: Para evitar las conexiones de equipos de la misma red, es habitual que los servidores/equipos cuenten con un firewall configurado mediante \textit{software} (ya sea a través de “Windows Firewall” o reglas nftables/iptables en GNU/Linux).

    \item \textbf{Cortafuego de aplicación}: Este tipo de cortafuegos es capaz de entender el protocolo de aplicación y de esta manera filtrar teniendo en cuenta el contenido del paquete.
\end{itemize}

A la hora de limitar el tráfico, un firewall puede actuar de dos maneras:
\begin{itemize}
    \item \textbf{Denegar por defecto}: Es la manera más habitual de trabajar de los Firewall. Por defecto, todo el tráfico es denegado, y hay que permitir el tráfico que nos interese.

    \item \textbf{Aceptar por defecto}: No tan habitual, ya que todo el tráfico es aceptado por defecto y debemos denegar el tráfico que no nos interese que exista.
\end{itemize}


\section{ACL}
Las ACL (\textit{Access Control Lists} en inglés, o Listas de Control de Acceso) sirven para permitir o denegar el tráfico al pasar por el router y son configuradas teniendo en cuenta las redes a las que pertenece.

Existen dos tipos de ACL:
\begin{itemize}
    \item \textbf{Estándar}: son ACLs limitadas. Sólo se permite aceptar o denegar de origen. El ID debe ser de 1 a 99.
    \item \textbf{Extendidas}: son ACLs con más opciones. Deben tener el ID de 100 a 199 y permiten aceptar/denegar:
    \begin{itemize}
        \item protocolo
        \item origen
        \item destino
        \item puerto
        \item ...
    \end{itemize}
\end{itemize}

Al crear una ACL en los routers de Packet Tracer, y crear una regla en ella, automáticamente entrará en funcionamiento el método “denegar por defecto” al final de las reglas.

\errorbox{Al crear una ACL extendida por defecto se crea una regla implícita
    \textbf{que deniega todo el tráfico. Se añade al final de nuestras reglas}.}

Es muy importante entender esto, ya que todo el tráfico que no esté aceptado, será denegado por defecto, aunque nosotros no hayamos creado una regla para ello, ya que se crea por defecto y no aparece reflejado en la ACL.

\infobox{\textbf{Al usar ACLs debemos usar la SIMULACIÓN si vemos que el tráfico no se acepta/deniega tal como esperamos.}}


\subsection{ACLs en entrada o salida}
Las ACLs se crean en los interfaces en los que queremos realizar reglas para permitir y/o denegar tráfico. Antes de permitir o denegar tráfico entre redes, hay que entender que las ACLs se pueden crear teniendo en cuenta el sentido del tráfico en relación con el router. Por lo tanto, las ACLs se pueden crear del tipo:

\begin{itemize}
    \item \textbf{IN}: el tráfico se analiza con la ACL \textbf{al intentar entrar en el router} por el interfaz indicado.
    \item \textbf{OUT}: el tráfico se analiza con la ACL \textbf{al intentar salir del router} por el interfaz indicado.
\end{itemize}

Podemos imaginar que la ACL es un policía y dependiendo de cómo se haya creado la ACL el policía se situará cortando el tráfico en un sentido o en otro.

Teniendo esto en cuenta, para realizar el mismo propósito se pueden utilizar distintas reglas IN o reglas OUT dependiendo de cómo se haga la configuración.

\textbf{Por ejemplo}: Tenemos 2 LANs y queremos que desde la LAN 1 se pueda hacer ping a la LAN 2, pero que desde la LAN 2 no se pueda hacer ping a la LAN 1. Para realizar este filtrado de tráfico, se puede realizar de dos formas distintas.

\paragraph{Forma 1: Regla OUT}

La regla OUT se creará en el interfaz Gig0/0 y analizará el tráfico cuando vuelva de la LAN 2 e \textbf{intente salir del router hacia la LAN 1}.

Se permitirá el tráfico que vuelve, pero sólo el tráfico de tipo “\textit{echo-reply}”. Cualquier otro tráfico es denegado por defecto

\begin{center}
    \vspace{-15pt}
    \includegraphics[width=0.5\linewidth]{acl_ejemplo.png}
    \vspace{-15pt}
\end{center}

\paragraph{Forma 2: Regla IN}
La regla IN se creará en el interfaz Gig 1/0 y \textbf{analizará el tráfico cuando entre al router desde la LAN 2}.

Se permitirá el tráfico entrante “echo-reply” y cualquier otro tipo de tráfico será bloqueado por defecto.


\subsection{Configurar y administrar ACLs}

A la hora de crear una ACL tenemos que tener en cuenta dos cosas:

\begin{itemize}
    \item El interfaz en el que queremos crear la ACL.
    \item El sentido en el que se realizará el filtrado.
\end{itemize}

\begin{mycode}{Crear una ACL en modo IN}{powershell}{}
Router(config)# interface GigabitEthernet0/0
Router(config-if)# ip access-group 100 in
\end{mycode}

Hemos indicado que se en el interfaz 0/0 existe una ACL con identificador 100 que filtrará el tráfico. A continuación debemos crear las reglas de las que constará ese grupo. Al crear una regla, se indican distintas opciones.

\begin{mycode}{Crear una regla en la ACL 100}{powershell}{{\footnotesize }}
Router(config)# access-list ID TIPO_FILTRADO TIPO_TRÁFICO ORIGEN  DESTINO  MISC
\end{mycode}

Donde las opciones son:
\begin{itemize}
    \item \textbf{ID}: sería el identificador de la regla, que tiene que coincidir con lo puesto en el interfaz correspondiente
    \item \textbf{TIPO\_FILTRADO}: Suele ser:
    \begin{itemize}
    \item \textbf{permit}: permitimos el tráfico
    \item \textbf{deny}: se bloqueará el tráfico
    \end{itemize}
    \item \textbf{TIPO\_TRÁFICO}: Existen varias opciones del tipo de tráfico que podemos filtrar:
    \begin{itemize}
        \item \textbf{icmp}: Internet Control Message Protocol
        \item \textbf{ip}: cualquier tipo de tráfico
        \item \textbf{tcp}: Transmission Control Protocol
        \item \textbf{udp}: User Datagram Protocol
    \end{itemize}
    \item \textbf{ORIGEN}: cuál es el origen del tráfico que se quiere coincidir con la ACL. Aquí puede haber varias opciones:
    \begin{itemize}
        \item \textbf{IP + WILDCARD}: habrá que indicar el rango de IP y el wildcard que se necesite. Esto servirá para indicar un rango de red.
        \item \textbf{any}: sirve para indicar cualquier IP.
        \item \textbf{host + IP}: sirve para habilitar un único host con su IP.
    \end{itemize}
    \item \textbf{DESTINO}: cuál es el origen del tráfico que se quiere coincidir con la ACL. Al igual que con el ORIGEN, existen varias opciones
    \item \textbf{MISC}: dependiendo del tipo de tráfico seleccionado, es posible añadir más opciones al final de la ACL.
\end{itemize}


Teniendo todo esto en cuenta, un ejemplo de regla para una ACL sería:

\begin{mycode}{Crear una regla en la ACL 100}{powershell}{{\scriptsize }}
Router(config)# access-list 100 permit icmp 192.168.2.0 0.0.0.255 192.168.1.0 0.0.0.255 echo-reply
\end{mycode}

\subsubsection{Orden de las reglas en las ACL}
Cada ACL puede tener varias reglas y \textbf{es muy importante el orden}. Es decir, si la ACL con ID 100 tiene varias reglas, se aplicarán en el orden de creación. Por lo tanto, primero se deben de aplicar las reglas más concretas, las que son más específicas, y después las más generales.

\textbf{Por ejemplo}: Queremos permitir todo el tráfico entre 192.168.1.0 → 192.168.20.0 pero queremos evitar el tráfico de 192.168.1.5 → 192.168.20.0. Entonces, el orden tendrá que ser:

\begin{itemize}
    \item \textbf{denegar} tráfico 192.168.1.5 → 192.168.20.0 /24 (porque es muy específico)
    \item \textbf{aceptar} tráfico 192.168.1.0 /24 → 192.168.20.0 /24
    \item denegar el resto de tráfico \textbf{¡¡REGLA POR DEFECTO, SE CREA SOLA!!}
\end{itemize}


\subsubsection{Otros ejemplos}
Si queremos hacer uso de DHCP en nuestra red, veremos que en el momento en el que aplicamos ACLs entre redes dejará de funcionar. Por lo tanto tendremos que aceptar el tráfico UDP de los puertos que usa \hyperlink{dhcp}{DHCP}.

Si queremos ver las ACL que están creadas, debemos hacer:
\begin{mycode}{Ver las ACLs y sus reglas}{powershell}{}
Router# show access-lists
\end{mycode}
