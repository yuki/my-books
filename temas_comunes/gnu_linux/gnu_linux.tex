\chapter{Introducción a GNU/Linux}
\section{Un poco de historia}
Para conocer cómo nació el movimiento GNU y el kernel Linux debemos conocer un poco de historia de la informática y cómo evolucionó en los primeros años.

\subsection{El nacimiento de Unix}

\begin{description}
\item[1964-1969]Los laboratorios \textbf{Bell} empiezan un proyecto con el \textbf{MIT} (Instituto Tecnológico de Massachusetts) y \textbf{General Electric} para desarrollar un sistema de \textbf{tiempo compartido} (“time-sharing computing”): se llamaría \textbf{Multics} (Multiplexed Information and Computing Service).

Hasta este momento, los sistemas utilizados eran de un único proceso, la CPU no era compartida por múltiples procesos sino que se ejecutaba por lotes (se les mandaba los procesos a ejecutar y se ejecutaban en orden).

Multics obtuvo licencia libre en el 2007. En Diciembre del 2016 salió la última versión 12.6f.

\itemimage{1969}{r}{0.33}
  {/Ken_Thompson_and_Dennis_Ritchie--1973.jpg}
  {\href{https://en.wikipedia.org/wiki/Ken_Thompson}{Ken y Dennis. Origen: Wikipedia}}
  {
  Uno de los desarrolladores de Multics, \href{https://en.wikipedia.org/wiki/Ken_Thompson}{Ken Thompson}, decidió escribir su propio sistema operativo. Ken Thompson es conocido también por crear el lenguaje de programación \textbf{B}, el sistema de codificación de caracteres UTF-8 y el lenguaje de programación Go, entre otras cosas.

A Ken Thompson se le une \href{https://en.wikipedia.org/wiki/Dennis_Ritchie}{Dennis Ritchie} y otros, y empiezan a programar un sistema de ficheros jerárquico, el concepto de procesos de computación, ficheros de dispositivos, un intérprete de comandos, … El resultado de lo programado era más pequeño y simple que Multics, lo que se convertiría en Unix. En Agosto ya tendrían el sistema operativo, se auto-gestiona,  tenía un assembler, un editor y una shell de comandos.

Dennis Ritchie es conocido también por crear junto con Ken el lenguaje de programación \textbf{C} (aparece por primera vez en 1972).
}


\item[1970]En ese momento el nuevo sistema operativo se llamaba \textbf{Unics} (\textit{Uniplexed Information and Computing Service}, un juego de palabras en contraposición a  Multics). No tenían todavía dinero de la organización en el desarrollo (era desarrollado por los programadores) y tampoco era multitarea todavía.

A finales de año el sistema ya era conocido como \textbf{UNIX}, y se había portado a la máquina PDP-11.

\textbf{Las primeras versiones de Unix incluían el código fuente} para que las universidades lo pudiesen modificar y así poder extenderlo a sus necesida des.


\item[1971]El sistema se empieza a hacer complejo y como querían que más usuarios lo usasen, crean el sistema de manuales que es utilizado hoy en día (mediante el comando \textbf{"man"}).

\begin{center}
  \includegraphics[width=0.8\linewidth]{/Ken_Thompson_(sitting)_and_Dennis_Ritchie_at_PDP-11_(2876612463).jpg}
  \vspace{-10pt}\captionof{figure}{\href{https://en.wikipedia.org/wiki/Ken_Thompson}{Dennis Ritchie y Ken Thompson trabajando en un PDP-11. Origen: Wikipedia}}\vspace{-13pt}
\end{center}


\item[1973]La versión 4 del sistema es reescrita completamente en C. Hasta este momento el sistema había estado escrito en ensamblador, por lo que no era portable entre distintos tipos de máquinas, aunque la primera versión portada a otra plataforma fue en 1978. Se cree que había “más de 20” instalaciones del sistema.

\item[1974]La versión 5 se licencia para ser utilizada en \textbf{instituciones educativas}.

\item[1975]La versión 6 se licencia para poder ser utilizadas por empresas por \$20.000 de la época.

\item[1977]La universidad de Berkeley lanza su primera versión de Unix bajo la Berkeley Software Distribution (BSD).

\item[1979]Con la salida de Unix v7, se comienza a portar a los distintos ``microordenadores'' de la época y a los distintos microprocesadores (Motorola 68000, Intel 8086, … ).

\item[1980]Microsoft anuncia su primer Unix para microcomputadoras de 16 bits (Xenix).
\end{description}

\subsection{El nacimiento de GNU (GNU's Not Unix}
\begin{description}

\item[1971]\href{https://en.wikipedia.org/wiki/Richard_Stallman}{Richard Stallman} comienza su carrera en el MIT en el laboratorio de inteligencia artificial.

Es conocido no sólo por el movimiento GNU, si no también por crear GCC y Emacs entre otra gran cantidad de software.

En esa época el software se distribuía de manera abierta para poder ser modificado. Lo habitual era realizar modificaciones para mejorar el software y distribuirlo entre compañeros y universidades.

\itemimage{1982}{r}{0.25}
  {/Richard_Stallman_2016_Talk_in_Madrid_06.jpg}
  {\href{https://commons.wikimedia.org/wiki/File:Richard_Stallman_2016_Talk_in_Madrid_06.jpg}{Richard Stallman: Wikimedia}}
  {
Richard Stallman quiere modificar el firmware de unas impresoras y el fabricante le pide que firme un acuerdo de no divulgación si le enseñan el código. Esto hace que Stallman se enfurezca y es cuando decide que la situación actual debe cambiar y volver al sistema de intercambio de software anterior.

\item[1983] Se anuncia el nacimiento del proyecto \textbf{GNU}, cuya finalidad es la de construir un sistema operativo completamente libre, compatible con Unix. La idea es dar a los usuarios la libertad y el control de sus ordenadores.

\item[1985] Se lanza el \href{https://www.gnu.org/gnu/manifesto.es.html}{manifiesto GNU}, y ya cuenta con un editor de texto (Emacs), compilador de C, una shell, varias utilidades … El núcleo inicial todavía no es funcional.
}


\item[1986]
Richard Stallman escribe y publica la definición de lo que es Free Software (Software Libre) a través de la \href{https://es.wikipedia.org/wiki/Free_Software_Foundation}{Free Software Foundation}.

\begin{tcolorbox}[title=Aclarando la palabra “free”:,sidebyside,righthand width=0.12\linewidth]

\textbf{The word “free” in our name does not refer to price; it refers to freedom.}

La palabra “free” no se refiere a gratis, si no que se refiere a libertad.

\tcblower
\includegraphics[width=\linewidth]{/gnu.png}
\end{tcolorbox}

Más adelante veremos a qué se refiere sobre libertad en el software.

\end{description}

\subsection{El nacimiento de Minix}
\begin{description}
\item[1987]Andrew S. Tanenbaum crea  Minix como propósito educativo y para enseñar cómo funciona un sistema operativo.

\item[1991]Sale la versión 1.5 de Minix y es portada a distintas arquitecturas (IBM, Motorola 68000, Amiga, Apple Macintosh, …).

\item[1992]Debate con Linus Torvalds sobre la arquitectura del kernel Linux (núcleo monolítico) en lugar de usar un micronúcleo.

\end{description}


\subsection{El nacimiento de Linux}
\begin{description}

\item[1991] Un estudiante en la universidad de Helsinki, \href{https://en.wikipedia.org/wiki/Linus_Torvalds}{Linus Torvalds}, comienza un proyecto personal escrito para su nuevo ordenador, un PC con procesador 80386.

El desarrollo comienza bajo \textbf{Minix}, usando el compilador \textbf{GCC} del movimiento GNU (GCC = GNU Compiler Collection).

El proyecto termina convirtiéndose en un kernel de un sistema operativo y escribió al grupo de noticias de Minix diciendo:

\begin{tcolorbox}[title=Email de Linus Torvalds presentando Linux,sidebyside,righthand width=0.30\linewidth]
  “Hola a todos los que estáis ahí fuera usando minix.\\


  Estoy haciendo un sistema operativo (libre), (solamente por aficion, no será grande ni profesional como el GNU) para clones 386(486) AT.

  ...

  PD. Sí – está libre de cualquier código de minix, y tiene un sistema de ficheros multi-hilo. NO es portable (usa el cambio de tareas del 386 etc), y probablemente nunca soporte otra cosa que no sean los discos duros AT, porque es todo lo que tengo :-(. ”
  \tcblower
  \includegraphics[width=\linewidth]{/Linus_Torvalds.jpeg}
  \vspace{-30pt}\captionof{figure}{\href{https://en.wikipedia.org/wiki/Linus_Torvalds}{Linus torvalds. Origen: Wikipedia}}
\end{tcolorbox}


\item[1992] Originalmente la licencia de Linux era propia e impedía el uso comercial de Linux. En la versión 0.99 esto cambia y se cambia a la licencia GNU Public License (\textbf{GPL}).

\item[1993] El proyecto cuenta con más de 100 desarrolladores. El kernel se adapta al entorno del proyecto GNU. Nace la distribución \textbf{Debian} (una de las más importantes a día de hoy)

\begin{center}
  \includegraphics[width=0.5\linewidth]{/debian-logo.jpg}
  \vspace{-10pt}\captionof{figure}{\href{https://www.debian.org}{Debian}}
\end{center}

\item[1994] Se libera la versión 1.0. El proyecto XFree86 se une y Linux consigue interfaz gráfico. Nacen las primeras distribuciones comerciales \textbf{Red Hat} y \textbf{Suse}.

\item[1998] Empresas como \textbf{IBM}, \textbf{Compaq} y \textbf{Oracle} anuncian que apoyan a Linux. Nace el interfaz gráfico \textbf{KDE}.

\item[1999] Nace el interfaz gráfico \textbf{GNOME} como reemplazo a KDE, ya que KDE hacía uso de una librería propietaria en aquel momento (QT).

\item[2001] Steve Ballmer (CEO de Microsoft) dice: \textbf{“Linux es un cáncer”}.

\item[2002] Se libera OpenOffice (originalmente suite ofimática de Sun Microsystems). Nace Mozilla (hoy día:  Firefox).

\item[2003] IBM lanza un anuncio para la Linux Foundation: \href{https://www.youtube.com/watch?v=x7ozaFbqg00}{https://www.youtube.com/watch?v=x7ozaFbqg00}

\item[2004] Nace \textbf{Ubuntu} (basándose en Debian) y Steve Ballmer (CEO de Microsoft) dice que Linux infringe muchas de sus patentes.

\item[2008] Nace \textbf{\href{https://es.wikipedia.org/wiki/Android}{Android}}, sistema operativo con kernel Linux. Actualmente es el sistema operativo de móviles que más terminales tiene.

\item[2009] Red Hat iguala a Sun Microsystem en capitalización bursátil (un gran logro simbólico).

\item[2014] Satya Nadella (CEO de Microsoft) muestra en una presentación la siguiente transparencia:

\begin{center}
  \includegraphics[width=0.5\linewidth]{/Microsoft_Linux.jpg}
  \vspace{-10pt}\captionof{figure}{\href{https://commons.wikimedia.org/wiki/File:Microsoft_Linux.jpg}{Origen: Wikipedia}}
\end{center}


\item[2016]
Microsoft anuncia \href{https://es.wikipedia.org/wiki/Windows_Subsystem_for_Linux}{WSL} (\textit{Windows Subsystem for Linux}) y se puede instalar en Windows 10 y Windows Server 2019. Permite correr ejecutables de Linux nativamente.

\end{description}

\subsection{Cronograma de sistemas Unix}
En el siguiente cronograma se puede ver la línea temporal de los sistemas Unix:

\begin{center}
  \includegraphics[width=0.7\linewidth]{/Evolución_UNIX.png}
  \vspace{-10pt}\captionof{figure}{\href{https://commons.wikimedia.org/wiki/File:Evolución_UNIX.png}{Origen: Wikipedia}}
\end{center}

\section{Resumen}
Linux es conocido como un sistema operativo libre pero el nombre de Linux se  centra única y exclusivamente en el \textbf{kernel} (o \textbf{núcleo}) del sistema operativo.

El sistema operativo completo debería llamarse \textbf{GNU/Linux}, ya que el kernel es una “pequeña” parte (aunque muy importante) dentro de todo el sistema operativo. El resto de herramientas utilizadas en el sistema operativo pertenecen al proyecto GNU.


\chapter{Licencias Libres}
\section{Software Libre}

En 1986 Richard Stallman saca a la luz la definición de lo que es Free Software (Software Libre) a través de la \href{https://es.wikipedia.org/wiki/Free_Software_Foundation}{Free Software Foundation}:

\begin{tcolorbox}[title=Aclarando la palabra “free”:,sidebyside,righthand width=0.12\linewidth]

    \textbf{The word “free” in our name does not refer to price; it refers to freedom.}

    La palabra “free” no se refiere a gratis, si no que se refiere a libertad.

    \tcblower
    \includegraphics[width=\linewidth]{/gnu.png}
\end{tcolorbox}


Las libertad en el software se refiere a:
\begin{tcolorbox}[title=Libertades del Software Libre:]
    \begin{enumerate}
        \setcounter{enumi}{-1}
        \item La libertad de ejecutar el programa, para cualquier propósito .

        \item La libertad de estudiar cómo trabaja el programa, y cambiarlo para que haga lo que usted quiera. El acceso al código fuente es una condición necesaria para ello.

        \item La libertad de redistribuir copias para que pueda ayudar al prójimo.

        \item La libertad de mejorar el programa y publicar sus mejoras, y versiones modificadas en general, para que se beneficie toda la comunidad. El acceso al código fuente es una condición necesaria.
    \end{enumerate}
\end{tcolorbox}

El movimiento del Free Software es un movimiento que tiene que ver más con la filosofía y la ética que con la tecnología en sí misma.


\subsection{Copyleft y GNU Public License (GPL)}
Es una práctica legal que consiste en el ejercicio del derecho de autor (copyright en inglés) con el objetivo de propiciar el libre uso y distribución de una obra, exigiendo que los concesionarios preserven las mismas libertades al distribuir sus copias y derivados (\href{https://es.wikipedia.org/wiki/Copyleft}{Wikipedia}).

\begin{center}
  \includegraphics[width=\linewidth]{Mapa_conceptual_del_software_libre.png}
  \vspace{-30pt}\captionof{figure}{\href{https://commons.wikimedia.org/wiki/File:Mapa_conceptual_del_software_libre.png}{Mapa conceptual del Software Libre: Wikipedia}}\vspace{-20pt}
\end{center}

Con esto nació la licencia GNU GPL, la cual permite al usuario final la libertad de usar, estudiar, compartir y modificar el software recibido. Tiene que quedar claro que un programa comercial puede ser Software Libre.

\subsection{Diferencias con el Open Source}
Los programas Open Source son aquellos que podemos ver el código fuente pero esto no quiere decir que podamos modificarlo o adaptarlo a nuestras necesidades.

El Open Source es menos restrictivo que el Software Libre y se puede decir que todo Software Libre es Open Source, pero no todo Open Source tiene por qué ser libre.


\section{Licencias libres más conocidas}
Un listado de las licencias libres más utilizadas:

\begin{itemize}
    \item \href{https://es.wikipedia.org/wiki/GNU_General_Public_License}{GNU GPL}
    \item \href{https://es.wikipedia.org/wiki/Licencia_BSD}{BSD}
    \item \href{https://es.wikipedia.org/wiki/Licencia_MIT}{MIT}
    \item \href{https://es.wikipedia.org/wiki/Apache_License}{Licencia Apache}
    \item \href{https://es.wikipedia.org/wiki/Licencia_PHP}{Licencia PHP}
    \item \href{https://es.wikipedia.org/wiki/Licencias_Creative_Commons}{Creative Commons} (no todas las versiones). Más utilizadas en contenido multimedia.
\end{itemize}


\chapter{Sistema de ficheros en GNU/Linux}
El sistema de ficheros en GNU/Linux, al igual que en Unix, es jerárquico, comenzando en la raíz denominada “/”. Partiendo de esta raíz, el resto del sistema de ficheros nace en forma de ramificaciones generando lo que se denominan “rutas de ficheros”, que es el camino completo para llegar al mismo.

\section{Filesystem Hierarchy Standard}
Debido a que en GNU/Linux todo se representa como ficheros (discos, dispositivos, programas, … ) es necesario que exista un orden a la hora de ser almacenados. Con esa intención nace en 1993 el estándar de la jerarquía de ficheros de Linux, enfocado a reestructurar los archivos. Posteriormente se unieron otros derivados de UNIX (la comunidad de desarrollo de BSD) por lo que terminó adoptando el nombre FHS.

Aún siendo un estándar, no todas las distribuciones lo siguen al pie de la letra, y otros Unix, como MacOS, tienen sus propias rutas especiales.


\section{Directorios importantes}
A continuación se exponen los directorios más importantes del sistema junto con la descripción del contenido que deben de tener:
\begin{itemize}

    \item \textbf{/boot/}: archivos de arranque del kernel, normalmente junto con la configuración utilizada para compilarlos.
    \item \textbf{/dev/}: contiene archivos especiales de bloque que representan los dispositivos del hardware que está corriendo el sistema operativo
    \item \textbf{/etc/}: contiene los archivos de configuración del servidor y de los servicios que corren en él. Está subdividido en directorios por servicios o configuraciones.
    \item \textbf{/home/}: los directorios de trabajo de los usuarios normales del sistema
    \item \textbf{/lib/}: librerías que hacen funcionar a los programas
    \item \textbf{/root/}: es la home del usuario root
    \item \textbf{/var/}: archivos variables del sistema
    \begin{itemize}
      \item \textbf{/var/lib/}: aquí se suelen guardar los ficheros de los programas que “crecen”: bases de datos, ficheros caché…
      \item \textbf{/var/log/}: los logs del sistema
    \end{itemize}
\end{itemize}

Junto a todos estos directorios, se ha separado los lugares en los que van los binarios, o ejecutables de los programas. Lo habitual es que se encuentren en estas rutas:

\begin{itemize}
    \item \textbf{/bin/}: aplicaciones esenciales del sistema
    \item \textbf{/sbin/}: aplicaciones que en principio sólo debería ejecutar el usuario root o programas de administración del sistema
    \item \textbf{/usr/bin/}: ejecutables de usuario
    \item \textbf{/usr/sbin/}: ejecutables de superusuario
\end{itemize}
Aunque las rutas de los ejecutables denotan quién debería ejecutar el programa, en la vida real no tiene por qué ser una limitación.

\section{Dispositivos de almacenamiento y discos duros}
En sistemas operativos Windows es habitual que cada partición cuente con una letra para acceder a ella, al igual que ocurre cuando introducimos un dispositivo de almacenamiento externo (un pendrive).

Tal como se ha comentado, en sistemas Unix el sistema de ficheros es una jerarquía, y por tanto todo dispositivo de almacenamiento nuevo deberá estar montado bajo la raíz “/”. Hoy día, en distribuciones con escritorio, al introducir un pendrive éste es auto-montado (es accesible) desde la ruta \textbf{/media/}, donde aparecerán tantos directorios como discos hayamos conectado.

\subsection{Almacenamiento permanente}
Si queremos que un disco duro nuevo sea permanente en nuestro sistema, podremos montarlo en cualquier lugar de la estructura jerárquica. Debido a este sistema, el usuario final no se tendrá que preocupar en almacenar los ficheros en una ruta distinta, si no que será el administrador el que haya hecho que esa ruta ahora pertenezca a un disco duro nuevo.

Imaginemos que el sistema operativo se ha instalado en un disco duro pequeño de 32Gb de espacio y se está llenando, y el directorio que más ocupa es el directorio de los usuarios. Podremos añadir al servidor un nuevo disco duro montado en /home y por tanto a partir de ahora los datos guardados en /home estarán en un nuevo disco duro más grande.

\begin{mycode}{Ejemplo de discos en un sistema con ``lsblk''`}{console}{}
root@vega:~# lsblk
NAME                       MAJ:MIN RM   SIZE RO TYPE MOUNTPOINTS
sda                          8:0    0   1,8T  0 disk
└─sda1                       8:1    0   1,8T  0 part /home/backup

sdb                          8:16   0   3,6T  0 disk
└─sdb1                       8:17   0   3,6T  0 part /home/disco4tb
sdc                          8:32   0 447,1G  0 disk
├─sdc1                       8:33   0   529M  0 part
├─sdc2                       8:34   0   100M  0 part
├─sdc3                       8:35   0    16M  0 part
└─sdc4                       8:36   0 446,5G  0 part
nvme0n1                    259:0    0 931,5G  0 disk
├─nvme0n1p1                259:1    0   512M  0 part
└─nvme0n1p2                259:2    0   800G  0 part /home
nvme1n1                    259:3    0 931,5G  0 disk
├─nvme1n1p1                259:4    0   512M  0 part /boot/efi
├─nvme1n1p2                259:5    0    90G  0 part /
├─nvme1n1p3                259:6    0   300G  0 part
│ ├─VMs-ubuntu--20.04--so1 254:0    0    10G  0 lvm
│ ├─VMs-manjaro            254:2    0    20G  0 lvm
│ └─VMs-win10              254:3    0    35G  0 lvm
└─nvme1n1p4                259:7    0 156,2G  0 part
\end{mycode}


\chapter{Gestión de usuarios locales en GNU/Linux}
En las distribuciones GNU/Linux lo habitual suele ser que existan al menos dos usuarios tras una instalación:

\begin{itemize}
    \item \textbf{root}: usuario administrador o súper usuario.
    \item \textbf{usuario no-privilegiado}: durante la instalación de la distribución nos suele preguntar para crear un usuario del sistema, que no tendrá privilegios.
\end{itemize}


El usuario root, como se ha dicho previamente, es el administrador del sistema, tiene permisos para realizar cualquier tarea dentro de nuestro sistema: instalar paquetes, desinstalarlos, modificar cualquier fichero, realizar formateos... Por lo tanto, el \textbf{realizar tareas como usuario root puede ser peligroso si cometemos algún fallo}.

Las buenas prácticas nos dicen que las tareas cotidianas del sistema deberíamos realizarlas como usuario normal y \textbf{sólo convertirnos en root cuando sea estrictamente necesario}.

\section{Creación de usuarios locales}

Tras instalar el sistema, veremos que se nos han creado varios usuarios en el sistema, aparte del usuario \textbf{root} y el usuario \textbf{no-privilegiado}. Para poder ver los usuarios que existen en nuestro sistema podemos verlo en el fichero \configfile{/etc/passwd} o podríamos obtener un listado ejecutando el siguiente comando:


\begin{mycode}{Listar usuarios del sistema}{console}{}
root@vega:~# cut -d: -f1 /etc/passwd
\end{mycode}

Para crear un usuario:

\begin{mycode}{Crear usuarios del sistema}{console}{\small}
root@vega:~# adduser mikeldi

Añadiendo el usuario `mikeldi' ...
Añadiendo el nuevo grupo `mikeldi' (1001) ...
Añadiendo el nuevo usuario `mikeldi' (1001) con grupo `mikeldi' ...
Creando el directorio personal `/home/mikeldi' ...
Copiando los ficheros desde `/etc/skel' ...
Nueva contraseña:
Vuelva a escribir la nueva contraseña:
passwd: contraseña actualizada correctamente
Cambiando la información de usuario para mikeldi
Introduzca el nuevo valor, o pulse INTRO para usar el valor predeterminado
    Nombre completo []:
    Número de habitación []:
    Teléfono del trabajo []:
    Teléfono de casa []:
    Otro []:
¿Es correcta la información? [S/n]
\end{mycode}

Y la línea que nos creará en el fichero  \configfile{ /etc/passwd }   es:
\begin{tcolorbox}[colback=white,title=Ejemplo de usaurio en “/etc/passwd”]
 \mintinline{console}{ mikeldi:x:1001:1001:mikeldi,,,:/home/mikeldi:/bin/bash }
\end{tcolorbox}

El fichero \configfile{ /etc/passwd }  nos muestra los datos de los usuarios, siendo un fichero que tiene distintos datos separados por “:”, siendo cada apartado:

\begin{center}
  \includegraphics[width=0.7\linewidth]{usuario_tabla.png}
\end{center}


En las primeras versiones GNU/Linux la contraseña de los usuarios aparecía en el propio fichero /etc/passwd, lo que suponía un problema en la seguridad, ya que no estaban cifradas. Actualmente, las contraseñas de los usuarios se almacenan cifradas en el fichero \configfile{ /etc/shadow }. El fichero es similar al passwd, estando separados los apartados por “:”


\begin{center}
  \includegraphics[width=0.7\linewidth]{shadow_tabla.png}
\end{center}


En el apartado de la contraseña podemos saber cierta información acerca de la misma ya que tiene el siguiente formato: \textbf{“\$id\$salt\$hashed”}
\begin{itemize}
    \item \textbf{id}: el algoritmo utilizado para cifrar la contraseña
    \begin{itemize}
        \item \$1\$ – MD5
        \item \$2a\$ – Blowfish
        \item \$2y\$ – Eksblowfish
        \item \$5\$ – SHA-256
        \item \$6\$ – SHA-512
    \end{itemize}
\end{itemize}

Aparte, también podemos encontrarnos con:
\begin{itemize}
    \item \textbf{Contraseña vacía}:  Si no hay contraseña, al pedirnos la contraseña a la hora de hacer login será suficiente con pulsar “intro”.
    \item \textbf{!}, \textbf{*}: la cuenta está bloqueada para la contraseña. El usuario no podrá loguearse utilizando la contraseña. Resulta útil si queremos bloquear el acceso con contraseña pero no con otros métodos (clave pública SSH).
    \item \textbf{*LK*}: cuenta bloqueda. El usuario no podrá loguearse.
    \item \textbf{*NP*}, \textbf{!!}: Nunca se ha puesto una contraseña
\end{itemize}


\section{Gestión de grupos}
En algunas distribuciones GNU/Linux, al crear un usuario directamente nos crea un grupo para el nuevo usuario. En otras, el usuario pertenece al grupo “users”.

Para saber los grupos a los que pertenece un usuario podemos ejecutar el comando \commandbox{ groups }. Los grupos del sistema aparecen en el fichero \configfile{ /etc/group }, y al igual que los ficheros vistos previamente, están separados por “\textbf{:}”.

\begin{center}
  \includegraphics[width=0.6\linewidth]{grupo_tabla.png}
\end{center}

\section{Permisos de ficheros}
En GNU/Linux los ficheros cuentan con 3 tipos de permisos:
\begin{itemize}
    \item lectura (\textbf{r}ead): el usuario puede leer el fichero
    \item escritura (\textbf{w}rite): el usuario puede escribir en el fichero
    \item ejecución (e\textbf{x}ecute): el usuario puede el fichero o puede ver el contenido de un directorio
\end{itemize}


Todos ello para los distintos usuarios que pueden existir en el sistema:
\begin{itemize}
    \item \textbf{dueño del fichero}: la persona que ha creado el fichero
    \item \textbf{grupo}: los usuarios pertenecientes al grupo al que pertenece el fichero tendrán ciertos privilegios
    \item \textbf{el resto de usuarios}: los permisos que tendrán el resto de usuarios que no son ni el dueño ni pertenecen al grupo
\end{itemize}

Todo ello se puede visualizar en el sistema de ficheros si listamos los permisos del fichero:

\begin{mycode}{Ver los permisos de un fichero}{console}{}
mikeldi@vega:~$ ls -lh fichero.txt
-rw-r--r-- 1 mikeldi mikeldi 0 dic  8 19:17 fichero.txt
\end{mycode}

Los permisos se pueden ver en los primeros 10 caracteres:

\begin{center}
  \includegraphics[width=0.7\linewidth]{permisos_fichero.png}
\end{center}

Existen los distintos tipos de ficheros:
\begin{itemize}
    \item \textbf{-} : fichero normal
    \item \textbf{d} : directorio
    \item \textbf{b} : dispositivo de bloque (ejemplo: /dev/sda*)
    \item \textbf{c} : dispositivo de carácter (las consolas. ejemplo: /dev/tty*)
    \item \textbf{s} : socket local
    \item \textbf{p} : tubería (pipe)
    \item \textbf{l} : enlace simbólico (link)
\end{itemize}

\subsection{Permisos especiales}

Existen otros permisos especiales:
\begin{itemize}
    \item \textbf{SUID}: permiso especial que permite que el fichero sea ejecutado con los permisos del dueño del fichero (aunque lo ejecute otro usuario). Se visualiza con una “S” en el permiso de ejecución del dueño  \texttt{-rwSrw-r- -} .
%% TODO: modificar los fondos de los permisos
    \item \textbf{SGID}: permiso especial que permite que el fichero sea ejecutado como el grupo. Aparece una “S” en el permiso de ejecución del grupo: \texttt{-rwx- -S- - -}.

    \item \textbf{STICKY}: si el bit sticky está activado en un directorio sólo el usuario root, el dueño del directorio o el dueño del fichero puede borrar ficheros de dicho directorio. Aparece una “t” en el permiso de ejecución del resto de usuarios: \inlineconsole{d-rwx-rx-r-t}.

\end{itemize}

\subsection{Cambiando permisos y dueños a los ficheros y a los directorios}

Para cambiar los permisos a los ficheros y a los directorios se hace con el comando \textbf{chmod}.

Para cambiar permisos de dueño a los ficheros y a los directorios se hace con el comando \textbf{chown}.

\section{La importancia de “sudo”}
En muchas distribuciones GNU/Linux el usuario no-privilegiado que se crea tiene permiso de “sudo” para poder ejecutar comandos como si se tratara del \textbf{root} (u otro usuario) para poder realizar tareas de administración. Es habitual que en estas distribuciones \textbf{el usuario root no suela tener contraseña}.

Cuando un usuario necesite realizar una tarea como administrador, deberá usar “sudo” antes del comando:

\begin{mycode}{Editar un fichero con permisos de root}{console}{}
mikeldi@vega:~$ sudo nano /etc/passwd
\end{mycode}

Tras realizar este comando, el sistema nos pedirá la contraseña del usuario con el que lo estemos ejecutando y comprobará que el usuario tiene permisos de “sudo” para poder ejecutar el comando (en este caso: nano).

El comando “\textbf{sudo}” viene de “\textbf{su}per user \textbf{do}” (que en inglés sería: “super usuario haz”), y aunque su uso habitual es el de permitir realizar cualquier comando de administración, la configuración permite mucho más, pudiendo permitir a ciertos usuarios sólo realizar ciertas tareas. Por ejemplo:

\begin{itemize}
    \item Usuario \textbf{mikeldi}: tendría permisos para poder realizar cualquier comando del sistema.
    \item Usuario \textbf{dba}: sólo tendría permisos para poder realizar el reinicio del sistema de base de datos.
    \item Usuario \textbf{adminweb}: sólo tendría permisos para poder realizar el reinicio del servidor web.
    \item ....
\end{itemize}

De esta manera, la gestión de nuestro servidor estaría basada en múltiples usuarios y cada usuario sólo sería capaz de realizar pequeñas tareas, por lo que la seguridad del servidor sería mayor y limitaría lo que los usuarios puedan realizar.

\subsection{Configurando “sudoers”}
Los permisos de sudo se realizan en el fichero  \configfile{/etc/sudoers} , y para su edición se hace uso del comando \textbf{visudo}, el cual abre el fichero y se asegura que a la hora de guardar la sintaxis es correcta.

Si realizamos cualquier modificación sobre el fichero, éste será tenido en cuenta la próxima vez que se realice la ejecución del comando “sudo”, por lo tanto, no hay que realizar ningún reinicio de servicio.

El fichero \configfile{/etc/sudoers}  tiene permisos de sólo lectura para el usuario root y el grupo root:

\begin{mycode}{Permisos del fichero \faFile \hspace{1pt} /etc/sudoers}{console}{}
root@vega:# ls -lh /etc/sudoers
-r--r----- 1 root root 669 jun  5  2017 /etc/sudoers
\end{mycode}

Un fichero sudoers suele tener el siguiente aspecto:

\begin{mycode}{Contenido del fichero \faFile \hspace{1pt} /etc/sudoers}{bash}{\footnotesize}
Defaults    env_reset
Defaults    mail_badpass
Defaults    secure_path="/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin"

# User privilege specification
root    ALL=(ALL:ALL) ALL

# Allow members of group sudo to execute any command
%sudo   ALL=(ALL:ALL) ALL

# See sudoers(5) for more information on "#include" directives:

#includedir /etc/sudoers.d
\end{mycode}

La línea que más importa en este fichero es la que indica “\textbf{\%sudo   ALL=(ALL:ALL) ALL}” y es explicada en su comentario anterior. Lo que quiere decir es que cualquier usuario que pertenezca al grupo “sudo” podrá realizar cualquier comando del sistema como superusuario. La sintaxis de la línea es:

\begin{itemize}
    \item \textbf{\%sudo}:  cualquier usuario que pertenezca al grupo “sudo”
    \item \textbf{ALL}= : desde cualquier host o IP
    \item \textbf{(ALL:ALL)}: el usuario que ejecuta puede ejecutar el comando como cualquier usuario y cualquier grupo
    \item \textbf{ALL}: puede ejecutar cualquier comando
\end{itemize}

Un ejemplo limitando el uso de sudo a un único comando a un usuario:

\begin{mycode}{Añadimos configuración al fichero \faFile \hspace{1pt} /etc/sudoers}{bash}{}
ruben    ALL=(ALL:ALL) NOPASSWD:/bin/systemctl suspend
\end{mycode}

Con esta línea lo que estamos permitiendo es que el usuario “ruben” puede ejecutar el comando “/bin/systemctl suspend” (suspender el equipo) y sin necesidad de meter contraseña al hacer sudo, gracias a la opción “NOPASSWD”).

\section{Diferencias entre “sudo”, “su” y “su -”}
Como ya se ha comentado en el apartado anterior, “sudo” permite la ejecución de comandos como cualquier usuario, siendo lo habitual ejecutarlo como root. Ahora bien, en entornos donde el usuario root tiene contraseña, nos puede interesar convertirnos en él para realizar tareas sin tener que estar ejecutando “sudo” a cada comando. Al ser root, tendremos que tener especial cuidado.

\subsection{Variables de entorno}
En cualquier sistema operativo existen las denominadas “variables de entorno”. Son variables que cada usuario tiene y sirven para indicar ciertos parámetros que se están utilizando (la SHELL que se está usando), o parámetros que se van a usar a la hora de ejecutar comandos o realizar tareas, ya que se consultan a ellas. En GNU/Linux las variables de entorno se pueden consultar ejecutando:

\begin{mycode}{Vemos las variables de entorno del usuario ruben}{console}{}
ruben@vega:~$ printenv
LANG=es_ES.utf8
LOGNAME=ruben
XDG_VTNR=2
COLORTERM=truecolor
PWD=/home/ruben
DESKTOP_SESSION=gnome
USERNAME=ruben
SHELL=/usr/bin/zsh
PATH=/usr/local/bin:/usr/bin:/bin:/usr/local/games:/usr/games
...
\end{mycode}

Una variable de entorno puede consultarse haciendo:

\begin{mycode}{Consultamos el contenido de la variable \$PATH}{bash}{}
ruben@vega:~$ echo $PATH
/usr/local/bin:/usr/bin:/bin:/usr/local/games:/usr/games

\end{mycode}

Como se puede ver, es con un “\textbf{\$}” y el nombre de la variable en mayúsculas. Existen muchas variables de entorno, y podríamos crear las nuestras propias si así lo necesitáramos.

\subsection{La importancia de “su -”}
Con el comando “\textbf{su}” nos podemos convertir en cualquier otro usuario del sistema siempre y cuando \textbf{conozcamos su contraseña}. Hay que notar la diferencia respecto a “\textbf{sudo}” que cuando lo ejecutamos nos pide \textbf{nuestra contraseña}.

\textbf{Al ejecutar “su” nos convertimos en el usuario root} (o ejecutando “su usuario2”, nos convertimos en el usuario2), \textbf{pero no hacemos uso de sus variables de entorno}, si no que seguimos  con las variables de entorno del usuario que éramos previamente.
Para convertirnos en el usuario y que obtengamos sus variables de entorno es necesario ejecutar “\textbf{su -}”, o lo que es lo mismo: “\textbf{su -l}”, que el manual nos dice: “\textit{Start the shell as a login shell with an environment similar to a real login}”. Por ejemplo:

\begin{mycode}{Consultamos el contenido de la variable \$PATH en distintas situaciones}{bash}{}
ruben@vega:~$ echo $PATH
/usr/local/bin:/usr/bin:/bin:/usr/local/games:/usr/games

ruben@vega:~$ su
Contraseña:

root@vega:/home/ruben# echo $PATH
/usr/local/bin:/usr/bin:/bin:/usr/local/games:/usr/games

root@vega:/home/ruben# exit

ruben@vega:~$ su -
Contraseña:

root@vega:~# echo $PATH
/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin

\end{mycode}

El usuario “ruben” tiene unos valores en la variable de entorno PATH (es la variable que se encarga de tener las rutas de los ejecutables de los programas). Al convertirse en root haciendo uso de “su”, y mirar la variable PATH, podemos observar que es igual que el usuario prueba.

Ahora bien, si a la hora de convertirse en root hace uso de “su -”, se puede ver cómo la variable PATH obtiene otros valores, siendo lo más significativo que aparecen las rutas “/usr/local/sbin” y “/usr/sbin” que son las rutas donde se almacenan los ejecutables que (en principio) sólo deberían ejecutarse como administrador del sistema.


\chapter{SAMBA}
\section{Introducción}
Samba es una implementación libre del protocolo de archivos compartidos que es utilizado por los sistemas Microsoft Windows para sistemas de tipo UNIX. De esta forma, es posible que ordenadores con GNU/Linux, Mac OS X o Unix en general se vean como servidores o actúen como clientes en redes de Windows.

Samba también permite validar usuarios haciendo de Controlador Principal de Dominio (PDC), como miembro de dominio e incluso como un dominio Active Directory para redes basadas en Windows.

Samba fue desarrollado originalmente para Unix por Andrew Tridgell utilizando un sniffer, o capturador de tráfico, para entender el protocolo usando \textbf{ingeniería inversa}.

\subsection{SMB/CIFS}
Server Message Block (\textbf{SMB}) y Common Internet File System (\textbf{CIFS}) son protocolos de red desarrollados para compartir archivos e impresoras entre nodos de una red. El protocolo SMB fue desarrollado originalmente por IBM y posteriormente ampliado por Microsoft y renombrado como CIFS.

Los términos SMB y CIFS son a menudo intercambiables pero hay características en la implementación de SMB de Microsoft que no son parte del protocolo SMB original. Sin embargo, desde una perspectiva funcional, ambos son protocolos utilizados por Samba.

La versión 1 del protocolo SMB no debería usarse, y en Samba está deshabilitado por defecto, debido a los ataques que hubo por el ransomware \href{https://es.wikipedia.org/wiki/Ataques_ransomware_WannaCry}{Wannacry}. Estos ataques utilizaban una vulnerabilidad en servidores que no estaban parcheados.

\section{Instalación}
Para instalar Samba haremos uso de los repositorios oficiales de nuestra distribución, y por tanto, podremos instalarlo haciendo uso del siguiente comando:

\begin{mycode}{Instalamos SAMBA y parte de las dependencias}{console}{}
root@vega:~# apt install samba cifs-utils smbclient winbind
\end{mycode}

Tras la instalación, nos habrá creado un directorio de configuración  \configdir{/etc/samba} , cuyo fichero de configuración principal es \configfile{/etc/samba/smb.conf} . Tras la instalación, tendremos un fichero de configuración estándar que no podrá realizar demasiado, ya que la configuración es escasa.

\section{Comprobar configuración}
Como ya se ha comentado, la configuración principal está en  \configfile{/etc/samba/smb.conf}  , con una configuración estándar, por lo que tendremos que adecuarla a nuestras necesidades.

Para asegurar que las modificaciones que hemos realizado son correctas, podremos hacer uso del siguiente comando:

\begin{mycode}{Comprobar configuración de Samba}{console}{}
root@vega:~# testparm
\end{mycode}

Es aconsejable ejecutarlo antes de realizar ningún reinicio del servicio, ya que de haber algún error el servicio se quedaría parado, y por tanto dejaríamos sin servicio a los usuarios.

Una vez realizado los cambios y comprobado que el fichero no contiene ningún error (al menos a nivel de sintaxis), reiniciamos el servicio de la siguiente manera:

\begin{mycode}{Reiniciar servicio de Samba}{console}{}
root@vega:~# systemctl restart smbd
\end{mycode}

El problema con el comando anterior es que Samba cuenta con varios servicios: smbd, nmbd, winbindd… por lo que para evitar que se nos olvide reiniciar uno, o asegurar que toda la configuración se recarga, lo mejor es hacer:

\begin{mycode}{Recargar toda la configuración de Samba}{console}{}
root@vega:~# smbcontrol all reload-config
\end{mycode}

Una vez reiniciada la configuración, podremos listar los servicios que está compartiendo y/o usando Samba con el siguiente comando:

\begin{mycode}{Resumen de la configuración de Samba}{console}{}
root@vega:~# smbclient -L localhost
\end{mycode}


\section{Samba como servidor “standalone”}
Samba tiene distintos modos de funcionar, siendo el sistema “standalone” el método por defecto que suele estar configurado en las distribuciones GNU/Linux.

Cuando el servidor está en este modo puede correr por sí solo o puede unirse a dominios de Windows. Es el método más sencillo de funcionar y \textbf{es utilizado para compartir carpetas de manera sencilla}.

Este modo “standalone” suele ser utilizado cuando tenemos pocos usuarios y sólo queremos compartir carpetas, como puede ser en casa o una oficina. En el momento en el que tenemos varios usuarios y queremos que nuestro servidor se convierta en un Active Directory \textbf{no tendremos que utilizar este modo}.


\section{Samba como Controlador de Dominio}
Desde la versión 4, se permite configurar Samba como un servidor de dominio al más puro estilo Active Directory siendo compatible con él, por lo que podremos hacer que nuestros equipos con Windows Pro se puedan conectar al dominio creado en Samba.

\subsection{Preparando el servidor}
Antes de realizar la configuración del Dominio tenemos que realizar una serie de modificaciones para dejar el servidor preparado.

\subsubsection{Poner IP estática}
Tal como hicimos con Windows Server, todo servidor debe de tener puesta una IP estática para poder realizar sus funciones de manera correcta. Para realizar la configuración de IP estática en Ubuntu los pasos están en el \hyperlink{configurar_ip_estatica_ubuntu}{anexo}.


\subsubsection{Modificación del DNS}
Ubuntu cuenta con un servidor DNS propio configurado en el sistema que nos puede causar problemas a la hora de ejecutar Samba y que entre en servicio su propio DNS, por lo tanto lo que se va a realizar en este apartado es desactivar el DNS de Ubuntu. En otras distribuciones (como sucede en Debian) este proceso no es necesario al no contar con un servidor DNS instalado previamente.

Los pasos para parar y desactivar el DNS son:

\begin{mycode}{Paramos y deshabilitamos el servicio DNS “resolved”}{console}{}
root@vega:~# systemctl stop systemd-resolved
root@vega:~# systemctl disable systemd-resolved
\end{mycode}

De no ejecutar estos comandos, Samba nos dará errores durante la ejecución. Estos comandos hacen que el DNS actual se pare y se deshabilite para que no se vuelva a activar en el siguiente arranque.

\errorbox{\textbf{¡Reiniciamos el servidor!} Así será más fácil realizar los siguientes pasos.}

Tras reiniciar, tenemos que hacer que nuestro servidor utilice el servicio DNS que va a levantar Samba. Para ello, tenemos que borrar el fichero  \configfile{/etc/resolv.conf}  (que realmente es un enlace simbólico creado por el anterior servicio), volverlo a crear y  asegurarnos que aparece lo siguiente:

\begin{mycode}{Configuración del fichero  \faFile \hspace{1pt} /etc/resolv.conf}{ini}{}
nameserver 127.0.0.1
\end{mycode}


\subsubsection{Configurar fichero /etc/hosts}
Antes de realizar la configuración del Dominio, tenemos que realizar una nueva configuración en el fichero  \configfile{/etc/hosts} , para que se vea reflejado lo siguiente:

\begin{mycode}{Configuración del fichero  \faFile \hspace{1pt} /etc/hosts}{ini}{}
127.0.0.1      localhost
192.168.1.200  dc.midominio.com dc
\end{mycode}

Donde:
\begin{itemize}
    \item \textbf{192.168.1.200}: es la IP de nuestro servidor (tendrás que modificar y poner la IP de tu equipo).
    \item \textbf{dc}: es el nombre del servidor que hemos puesto durante la instalación (cuidado que sale dos veces).
    \item \textbf{midominio.com}: es el dominio que queremos configurar a continuación en Samba.
\end{itemize}
Con esto hecho, podremos continuar y configurar Samba como nuestro Controlador de Dominio.

\subsection{Configurar Samba como Controlador de Dominio}
Para comenzar con la configuración de Samba como un controlador de dominios para sistemas Windows tendremos que parar el servidor Samba:

\begin{mycode}{Paramos todos los servicios de SAMBA}{console}{}
root@vega:~# smbcontrol all shutdown
\end{mycode}

Esto hace que los servicios de Samba (\textbf{smbd} y \textbf{nmbd}) se paren. Debido a que el fichero de configuración va a sufrir grandes cambios, y la configuración que tiene tras la instalación no es necesaria, se va a mover el fichero de configuración para guardarlo como backup:

\begin{mycode}{Movemos el fichero de configuración original de SAMBA}{console}{}
root@vega:~# cd /etc/samba
root@vega:~# mv smb.conf smb.conf_backup
\end{mycode}

Al igual que hicimos con Windows Server a la hora de crear Active Directory, en Samba también vamos a necesitar de un DNS que esté gestionado por el propio controlador de dominio. En nuestro caso, como veremos más adelante, \textbf{Samba levantará un DNS propio}, pero tendremos que hacer que nuestro sistema GNU/Linux haga uso de él, tal como se explicará en el siguiente apartado.

Antes de eso, para realizar la configuración inicial del dominio, tenemos que ejecutar:

\begin{mycode}{Usamos el asistente de creación del dominio }{console}{}
root@vega:~# samba-tool domain provision
\end{mycode}

Nos va a realizar una serie de preguntas, que tendremos que contestar:
\begin{itemize}
    \item \textbf{Realm}: el nombre del Dominio que queremos crear. Ejemplo: \textbf{mikeldi.com}.

    \item \textbf{Domain}: Nombre de dominio \textbf{NETBIOS}. Debe ser una única palabra de máximo 15 caracteres. Por ejemplo MIKELDI.

    \item \textbf{Server Role}: Es el tipo de rol que va a tener nuestro servidor. Puede ser uno de los siguientes:

    \begin{itemize}
        \item \textbf{dc}: Domain Controller, es decir, controlador de dominio de Windows. Este es el modo que nos va a interesar en nuestro caso, ya que actuará como si se tratara de un Active Directory.

        En el fichero de configuración nos aparecerá como “active directory domain controller”

        \item \textbf{member}: Miembro de un dominio. Nos permitiría que Samba sea un miembro de un dominio Windows.

        \item \textbf{standalone}: Este es el modo por defecto una vez hemos instalado Samba, tal como se ha comentado previamente.
    \end{itemize}

    \item \textbf{DNS backend}: Servidor backend de DNS. Al igual que Windows hacía uso de DNS, Samba cuando se convierte en controlador de dominio también. Existe la posibilidad de utilizar un servidor DNS propio (como Bind) pero en caso de usar “\textbf{SAMBA\_INTERNAL}” Samba levantará un DNS propio.

    \item \textbf{DNS forwarder IP address}: El DNS al que se preguntará los DNS que desconocemos. Podemos poner el de Google, 8.8.8.8, o cualquier otro DNS público.

    \item \textbf{Administrator password}:  Contraseña del administrador del Controlador de Dominio.
\end{itemize}

Una vez realizada la configuración inicial, antes de arrancar tenemos que instalar Winbind, que es necesario, y por si acaso lo paramos, para que después lo arranque Samba:

\begin{mycode}{Paramos el servicio winbind}{console}{}
root@vega:~# systemctl stop winbind
\end{mycode}

Hay que recordar que \textbf{ahora mismo tenemos el servicio de Samba parado}, y lo único que hemos realizado ha sido la configuración inicial, por lo que el fichero de configuración  \configfile{/etc/samba/smb.conf}  ha sido modificado teniendo en cuenta las respuestas que hayamos dado previamente.

\subsubsection{Arranque en modo interactivo}
Tras realizar los pasos anteriores, nuestro servidor está listo para arrancar en modo Domain Controller, para ello en una consola ejecutaremos:

\begin{mycode}{Arrancamos SAMBA en modo interactivo}{console}{}
root@vega:~# samba -F -i -d1
\end{mycode}

Los parámetros “-F -i -d1” sirve para arrancar Samba y que podamos ver qué está sucediendo durante la ejecución de Samba. Arrancarlo así nos sirve para poder ver si existe algún error en tiempo real. Una vez todo sea correcto, podríamos parar la ejecución de este comando (con \textbf{ctrl+c}) y lanzar el demonio de manera normal.

Para ver los puertos que está usando Samba (como el 53 del DNS) podríamos ejecutar el siguiente comando:

\begin{mycode}{Comprobamos los puertos utilizados por SAMBA}{console}{\fontsize{7.6pt}{7pt}}
root@vega:~# ss -puntal | grep smb

Netid  State   Recv-Q  Send-Q    Local Address:Port    Peer Address:Port  Process
tcp    LISTEN  0       50        0.0.0.0:139          0.0.0.0:*      users:(("smbd",pid=6041,fd=47))
tcp    LISTEN  0       50        0.0.0.0:445          0.0.0.0:*      users:(("smbd",pid=6041,fd=46))
tcp    LISTEN  0       50        [::]:139             [::]:*          users:(("smbd",pid=6041,fd=45))
tcp    LISTEN  0       50        [::]:445             [::]:*          users:(("smbd",pid=6041,fd=44))
\end{mycode}

\subsubsection{Usuarios en Samba Domain Controller}
Al igual que sucedía en Active Directory, Samba tiene un sistema para la gestión y creación de usuarios que pertenecen al Domain Controller. A partir de ahora, la gran mayoría de los comandos que ejecutemos serán parámetros del siguiente comando, que es el sistema principal de administración de Samba:

\begin{mycode}{Comando para controlar nuestro dominio en SAMBA}{console}{}
root@vega:~# samba-tool
\end{mycode}

Para crear los usuarios dentro del dominio gestionado por Samba podremos crearlos de la siguiente manera:

\begin{mycode}{Crear nuevo usuario en SAMBA}{console}{}
root@vega:~# samba-tool user create mikeldi
\end{mycode}

Si queremos visualizar todos los usuarios que existen en Samba podemos hacerlo con:

\begin{mycode}{Crear nuevo usuario en SAMBA}{console}{}
root@vega:~# samba-tool user list
mikeldi
Administrator
Guest
krbtgt
\end{mycode}

Tal como se puede ver, aparece el usuario “mikeldi” creado previamente, junto con los usuarios que también se creaban por defecto en Active Directory:

\begin{itemize}
    \item \textbf{Administrator}: administrador del dominio
    \item \textbf{Guest}: usuario invitado
    \item \textbf{krbtgt}: de manera resumida, usuario desactivado que es el encargado del sistema de autenticación (Kerberos).
\end{itemize}


Toda la gestión de usuarios del dominio Samba se podrá hacer con el comando  \commandbox{samba-tool user} añadiendo el correspondiente parámetro extra.


\warnbox{\textbf{No hay que confundir la gestión de usuarios de Samba con la propia de Linux, ya que son dos cosas completamente separadas.}}


\subsubsection{Configuración del Controlador de Dominio}
Tal como se ha comentado previamente, el comando  samba-tool  nos permitirá realizar todo tipo de configuraciones, como pueden ser:
\begin{itemize}
    \item Gestión de ordenadores del dominio
    \item Gestión de usuarios
    \item Gestión de grupos
    \item …
\end{itemize}

\subsection{Meter Windows 10 en Samba Domain Controller}
Ha llegado el momento de meter un equipo Windows en el Dominio que tenemos gestionado por nuestro servidor Samba. Los pasos a dar serán los mismos que cuando metemos el equipo en un Active Directory.
\begin{itemize}
    \item \textbf{Cambiar el nombre al equipo}: Esto hará que después sea más fácil realizar la gestión de equipos y saber a quién pertenece el equipo o dónde se sitúa.
    \item \textbf{Cambiar DNS} del equipo para que haga uso de la IP del servidor Samba.
    \item Vamos a “\textbf{Panel de Control > Sistema y Seguridad > Sistema}”: Aquí le damos a “Cambiar configuración” dentro de la configuración de Dominio, y lo añadimos a nuestro Dominio creado previamente. Para añadirlo haremos uso del usuario Administrador que tenemos creado en el Controlador de Dominio Samba. Como pasaba al añadirlo a un Active Directory, el equipo tendrá que reiniciarse.
\end{itemize}
Una vez añadido el equipo, podremos loguearnos usando el usuario creado previamente.

\section{Compartiendo carpetas mediante Samba}
En algunas distribuciones, en la configuración por defecto de Samba ya aparece la compartición de ciertas carpetas. Normalmente suele aparecer la carpetas “home” de los usuarios, pero esta configuración es válida \textbf{cuando Samba está en modo “standalone”} siendo la configuración base la siguiente:


\begin{mycode}{Ejemplo que aparece en \faFile /etc/samba/smb.conf}{ini}{}
[homes]
    browseable = No
    comment = Home Directories
    create mask = 0700
    directory mask = 0700
    read only = No
    valid users = %S
\end{mycode}

Si desde un windows nos intentamos conectar a nuestro Samba haciendo uso de \textbf{\textbackslash \textbackslash IP\_Samba\textbackslash nombre\_usuario}  donde:

\begin{itemize}
    \item \textbf{IP\_Samba}: es la IP de nuestro servidor Samba
    \item \textbf{nombre\_usuario}: es el usuario que tengamos en la base de datos de Samba veremos que se intentará conectar, y en caso de que coincida la contraseña de windows con la de Samba, podremos visualizar el directorio.
\end{itemize}

\infobox{Windows no tiene por qué estar dentro del dominio de Samba para acceder a una unidad compartida por Samba.}

Esta configuración \textbf{no es válida cuando Samba está en modo controlador de dominio}, pero nos puede servir de base para crear nuestras carpetas compartidas.

\subsection{Crear carpeta compartida}
Para crear una carpeta compartida accesible por los usuarios creados en Samba, podemos modificar el fichero de configuración y añadir una sección que sea similar a la siguiente:

\begin{mycode}{Configuración para compartir una carpeta en SAMBA}{ini}{}
[sistemas]
    browseable = No
    comment = Carpeta Sistemas compartida
    path = /home/sistemas
    create mask = 0777
    directory mask = 0777
    read only = No
    valid users = mikeldi
\end{mycode}

Esta sección cuenta con distintos parámetros que hay que entender:
\begin{itemize}
    \item \textbf{[sistemas]}: es el nombre de la carpeta tal como accederemos desde Windows.
    \item \textbf{browseable}: indica si la carpeta puede ser “buscada” accediendo al servidor o si debemos conocer cómo se llama la carpeta para acceder a ella directamente.
    \item \textbf{comment}: comentario sobre la carpeta compartida.
    \item \textbf{path}: ruta en el servidor GNU/Linux donde realmente se encuentra la carpeta compartida.
    \item \textbf{create mask}: cuando se crea un fichero en la carpeta compartida, los permisos que tendrá el fichero en GNU/Linux.
    \item \textbf{directory mask}: cuando se crea un directorio en la carpeta compartida, los permisos que tendrá el fichero  en GNU/Linux.
    \item \textbf{read only}: si queremos que la carpeta compartida sea de modo sólo lectura.
    \item \textbf{valid users}: usuarios que podrán acceder a la carpeta compartida. Estos usuarios deberán haber sido creados previamente en Samba (mirar apartado de creación de usuarios).
    \begin{itemize}
        \item Si queremos que puedan conectarse varios usuarios, deberemos poner el listado separado por espacios.
        \item Si queremos que puedan conectarse a esta carpeta todos los usuarios de un grupo, deberemos poner \textbf{@nombre\_grupo} en esta variable.
    \end{itemize}
\end{itemize}

\section{Administración remota de Samba, desde Windows}
Quizá nos interese administrar nuestro nuevo servidor de controlador de dominio desde un equipo Windows, para ello necesitaremos instalar las “\textbf{Herramientas de administración remota del servidor}” que las podemos descargar de la \href{https://www.microsoft.com/es-es/download/details.aspx?id=45520}{web de Microsoft} (actualmente la versión “WindowsTH-RSAT\_WS\_1803-x64.msu”).

Desde “\textit{Panel de Control → Sistema y Seguridad → Herramientas Administrativas}” veremos distintas herramientas para administrar el Controlador de Dominio, que tendremos que ejecutar como Administrador en Windows (y que nos pedirá contraseña del Administrador de Samba).

\chapter{Creación de copias de seguridad en GNU/Linux}
Tal como hemos visto, la \hyperlink{gestion_copias_de_seguridad}{gestión de copias de seguridad} es de vital importancia para preservar los datos de nuestra empresa. Debemos interiorizar que el realizar copias de seguridad, tanto en nuestro ámbito personal como profesional, es una parte en la gestión de nuestra información así como el comprobar que se realizan de manera correcta.

Al igual que sucede en Windows, existen múltiples sistemas para realizar copias de seguridad en GNU/Linux, pero uno de los más sencillos de utilizar ya suele venir instalado en la gran mayoría de las distribuciones hoy día: \textbf{rsync}.


\section{Rsync como sistema para sincronizar directorios}
Rsync es una aplicación que ofrece la posibilidad de realizar la sincronización de directorios (de manera local o en remoto) de manera eficiente, ya que es capaz de sincronizar sólo las modificaciones realizadas en los ficheros.

Por defecto, \textbf{rsync} copia las modificaciones o ficheros nuevos que existen en el directorio de origen y los copia al directorio de destino. Si un fichero es borrado en el directorio origen,\textbf{ por defecto no se borra en el directorio de destino}.

La manera más sencilla de utilizar rsync es para crear una sincronización de un directorio local a un servidor remoto en el que almacenar una copia de los datos.

\errorbox{\textbf{Esta sincronización remota equivale a realizar una copia completa de todos los datos (de manera recursiva), o lo que es lo mismo, un \textit{full-backup}.}}

\begin{mycode}{Ejemplo para sincronizar dos directorios locales}{console}{}
ruben@vega:~$ rsync -av directorio_origen  directorio_destino
\end{mycode}

En el ejemplo anterior lo que hace es sincronizar todo el “directorio\_origen” dentro del “directorio\_destino”. En cambio:

\begin{mycode}{Ejemplo para sincronizar dos directorios locales}{console}{}
ruben@vega:~$ rsync -av directorio_origen/  directorio_destino2
\end{mycode}

En este ejemplo, como hemos añadido una barra “/” al final del directorio origen, lo que estamos indicando es que el contenido (y sólo el contenido) se va a sincronizar dentro de “directorio\_destino2”.

\errorbox{Hay que tener cuidado con esa “\textbf{/}”, ya que ponerla o no ponerla da resultados distintos en la sincronización.}

\subsection{Rsync para sincronizar de manera remota}
Tal como sabemos, nunca deberíamos realizar copias de seguridad de manera local en el mismo disco duro, ni tenerlas en el mismo equipo, por lo que es necesario poder realizar copias de seguridad desde otros servidores o a otros servidores.

Imaginemos que queremos copiar los datos de una carpeta compartida \configdir{/home/sistemas} al servidor remoto 10.40.30.200, y dejar una copia en \configdir{/home/backups}:

\begin{mycode}{Sincronizar directorio local a servidor remoto}{console}{}
ruben@vega:~$ rsync -av /home/sistemas  root@10.40.30.200:/home/backups
\end{mycode}

Con este comando realizaremos la sincronización al servidor remoto haciendo uso de \hyperlink{ssh_server}{SSH} y conectándonos con el usuario root remoto. Explicación de los distintos apartados del comando:
\begin{itemize}
    \item \textbf{rsync} es el programa que usamos para realizar la sincronización.
    \item \textbf{-av} son los parámetros que realizan la sincronización en moodo archivos y en modo “verbose” (nos indica qué está sincronizando).
    \item \textbf{/home/sistemas} es el directorio con los datos de origen que vamos a sincronizar
    \item \textbf{root} es el usuario con el que nos vamos a conectar al servidor remoto.
    \item \textbf{@10.40.30.200:} es el servidor al que nos vamos a conectar por SSH para realizar en él la copia. \textbf{¡OJO!} Es importante esa “@” y los “:“ al final.
    \item \textbf{/home/backups} es el lugar donde dejaremos una copia de los datos a sincronizar.
\end{itemize}

Tal como se ha comentado, rsync hará uso de SSH para realizar la conexión remota, por lo que los datos se enviarán de manera segura y cifrada.

\subsection{Obtener datos remotos}
Si queremos realizar la sincronización en el orden inverso, obtener los datos estando en el servidor de backup y traernos los datos de un servidor remoto, el comando sería:

\begin{mycode}{Sincronizar directorio remoto a directorio local}{console}{}
root@backups:~# rsync -av 10.40.30.5:/home/sistemas  /home/backups
\end{mycode}

En este caso, estando en el servidor de backups, vamos a traernos los datos del servidor 10.40.30.5. En este caso, antes de la IP del servidor no hemos puesto usuario, por lo que se realizará la conexión con el mismo usuario que somos actualmente, en este caso \textbf{root}.

\subsection{Opciones extra}
Hasta ahora hemos visto las opciones más básicas para sincronizar directorios (tanto locales como remotos), pero rsync cuenta con muchas opciones extra que es interesante conocer:

\begin{itemize}
    \item \textbf{-z} o {\textbf{\-/-compress}} sirve para comprimir los datos antes de realizar el envío o recepción de los datos. Sólo es útil si vamos a realizar la sincronización de manera remota.
    \item \textbf{\-/-progress} sirve para ver el progreso de cómo va la transferencia de los ficheros
    \item \textbf{\-/-delete} sirve para borrar en el destino los ficheros que no existen en el origen.
    \item \textbf{\-/-exclude "*txt"} excluye los ficheros que termina con la extensión “txt” al hacer la sincronización.
\end{itemize}





\chapter{Comandos de administración básica en GNU/Linux}
A lo largo de este documento hemos visto distintos comandos para realizar la administración de usuarios y grupos locales o para crear un directorio activo en Samba. En este documento vamos a añadir otros comandos que nos pueden ser útiles a la hora de usar un sistema GNU/Linux y realizar su administración.

\section{Comandos de red}
Para ver los interfaces de red y las direcciones IP que tienen

\begin{mycode}{Obtener los interfaces y las IPs}{console}{}
ruben@vega:~$ ip a
1: lo: <LOOPBACK,UP,LOWER_UP> mtu 65536
link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
inet 127.0.0.1/8 scope host lo

2: enp4s0: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500
link/ether 1a:8a:1c:ff:25:15 brd ff:ff:ff:ff:ff:ff
inet 192.168.1.99/24 brd 192.168.1.255 scope global enp4s0
\end{mycode}

Para ver la ruta por defecto (el gateway o puerta de enlace).

\begin{mycode}{Obtener la puerta de enlace}{console}{}
ruben@vega:~$ ip route show default
default via 192.168.1.1 dev enp4s0 onlink
\end{mycode}

Ver los puertos TCP y servicios que están a la escucha en nuestro servidor
\begin{mycode}{Listar los puertos TCP a la escucha}{console}{}
root@vega:~# ss -pntal
\end{mycode}

\section{Comandos sobre procesos}
Listar todos los procesos
\begin{mycode}{Listar todos los procesos}{console}{}
root@vega:~# ps aux
\end{mycode}

Listar todos los procesos en forma de árbol (para saber de quién son hijos)
\begin{mycode}{Listar todos los procesos en forma de árbol}{console}{}
root@vega:~# pstree -p
\end{mycode}

Matar un proceso (donde PID es el identificador del proceso).
\begin{mycode}{Matar un proceso}{console}{}
root@vega:~# kill -9 PID
\end{mycode}

\section{Estado de la carga y memoria del servidor}
Para ver los procesos y su estado por consumo de CPU, RAM…
\begin{mycode}{Ver el estado del servidor}{console}{}
root@vega:~# top
\end{mycode}

Para ver los procesos y su estado por consumo de CPU, RAM… es necesario instalar este paquete
\begin{mycode}{Ver el estado del servidor}{console}{}
root@vega:~# htop
\end{mycode}

\section{Comandos sobre servicios (systemd/systemctl)}
GNU/Linux cuenta con un sistema unificado (\textbf{systemd}) para administrar el sistema y los servicios que tenemos en nuestro servidor. Dado que es una pieza fundamental en el sistema operativo, debemos de conocer ciertos comandos para poder desempeñar tareas con él.

Listar todos los servicios/unidades
\begin{mycode}{Listar todos los servicios}{console}{}
root@vega:~# systemctl
\end{mycode}

Comprobar si algún servicio ha fallado
\begin{mycode}{Comprobar servicios que han fallado}{console}{}
root@vega:~# systemctl --failed
\end{mycode}

Comprobar el estado de un servicio concreto (en este caso, ssh)
\begin{mycode}{Comprobar servicios que han fallado}{console}{}
root@vega:~# systemctl status ssh
\end{mycode}

Parar un servicio concreto
\begin{mycode}{Parar un servicio concreto}{console}{}
root@vega:~# systemctl stop ssh
\end{mycode}

Arrancar un servicio concreto
\begin{mycode}{Arrancar un servicio concreto}{console}{}
root@vega:~# systemctl start ssh
\end{mycode}

Ver los logs de todo el sistema
\begin{mycode}{Ver los logs del sistema}{console}{}
root@vega:~# journalctl
\end{mycode}

Ver los logs de un servicio concreto (en este caso, ssh)
\begin{mycode}{Ver los logs del sistema}{console}{}
root@vega:~# journalctl -u ssh
\end{mycode}

Ver los logs del kernel
\begin{mycode}{Ver los logs del kernel}{console}{}
root@vega:~# journalctl -k
\end{mycode}