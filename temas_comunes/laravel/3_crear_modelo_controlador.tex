\chapter{Introducción}

Ahora que ya tenemos el entorno creado, es momento de empezar a añadir funcionalidad básica a nuestra aplicación y comenzar a crear nuestra aplicación. Para estos ejemplos se ha decidido crear una pequeña aplicación a modo de blog, con posts y comentarios.

\chapter{Artisan}
\href{https://laravel.com/docs/10.x/artisan}{Artisan} es la interfaz de línea de comandos que vamos a utilizar para realizar todo tipo de interacción entre el proyecto y el propio \textit{framework} Laravel. Esta interfaz nos va a permitir, entre otras cosas:

\begin{itemize}
    \item Crear modelos y controladores.
    \item Crear una sesión a la base de datos.
    \item Controlar el estado de los “migrations”.
    \item Hacer uso de los “seeds” en la base de datos.
    \item Limpiar la caché de objetos.
\end{itemize}

Cada comando contará con su ayuda, por lo que es recomendable ir mirando la ayuda y así conocer las distintas opciones para cada uno de ellos.


\chapter{Crear modelo “Posts”}
Un blog tiene una serie de “Posts”, que son las entradas que los usuarios introducen en el blog. De momento vamos a ignorar el apartado de usuarios, para simplificarlo. Una entrada del blog contará con los siguientes atributos:

\begin{itemize}
    \item Título
    \item Texto
    \item Si está publicada o no
\end{itemize}

Para crear el modelo, ejecutaremos el siguiente comando. Este comando lo debemos ejecutar dentro del contenedor Docker y dentro de la ruta donde se encuentra el proyecto Laravel, que es \configdir{/var/www/html}:

\begin{mycode}{Crear Modelo}{console}{}
root@1b29e46c10ae:/var/www/html# php artisan make:model Post -crms
\end{mycode}

Este comando nos va a crear el modelo Post junto con:
\begin{itemize}
    \item \textbf{Controlador} de tipo “resource”, lo que va a permitir distintas acciones sobre él: listar, crear, ver, ...
    \item \textbf{\textit{Migration}}: Un fichero para realizar la migración del modelo en la base de datos.
    \item \textbf{\textit{Seed}}: Un fichero de tipo “semilla” para introducir datos en la base de datos.
\end{itemize}


\chapter{Entendiendo las “\textit{migrations}” de base datos}

Hoy en día son muchos los \textit{frameworks} que hacen uso de sistemas de tipo \textbf{\textit{migration}} a la hora de interactuar en el tiempo con la base de datos. Podríamos definirlo como un \textbf{sistema de control de versiones para el esquema de base de datos}.

Este sistema permite ir evolucionando el esquema de base de datos (tablas, columnas de las tablas, funciones...) a medida que el propio código fuente de la aplicación va evolucionando. De esta manera, si tenemos el código en un punto concreto, con el sistema \textbf{migrations} nos va a crear la base de datos tal como se necesita en ese punto.

Al crear nuestro proyecto Laravel, ya contamos con una serie de ficheros de migraciones para la base de datos. Estos ficheros se encuentran en \configdir{app/database/migrations/}, teniendo cada fichero un formato similar a \configfile{YYYY_mm_dd_HHMMSS_comentario.php} siendo:

\begin{itemize}
    \item \textbf{YYYY}: el año que se ha creado el fichero.
    \item \textbf{mm}: el mes que se ha creado el fichero.
    \item \textbf{dd}: el día que se ha creado el fichero.
    \item \textbf{HHMMSS}: la hora, minuto y segundo.
    \item \textbf{comentario}: un pequeño comentario sobre el contenido del fichero.
\end{itemize}

De esta manera, los migrations se van a poder ejecutar en orden de fecha de creación, donde normalmente suele ser:
\begin{itemize}
    \item \textbf{De más antiguo a más nuevo}: Se van creando las tablas, y se van añadiendo modificaciones. Es el ciclo normal de de desarrollo, y este es el sistema de uso habitual.
    \item \textbf{De más nuevo a más antiguo}: Se vuelve atrás en el proyecto, eliminando modificaciones. Utilizado para ir a una versión antigua del proyecto.
\end{itemize}

Vamos a utilizar como ejemplo el primer fichero que existe en el directorio, que es para hacer uso de la tabla de usuarios del sistema de autenticación de Laravel. El fichero tiene una clase que extiende de la clase \textbf{Migration} con dos funciones:

\begin{mycode}{Fichero Migration}{PHP}{}
<?php
use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration {
    public function up(): void {
        Schema::create('users', function (Blueprint $table) {
            $table->id();
            $table->string('name');
            $table->string('email')->unique();
            $table->timestamp('email_verified_at')->nullable();
            $table->string('password');
            $table->rememberToken();
            $table->timestamps();
        });
    }

    public function down(): void {
        Schema::dropIfExists('users');
    }
};
\end{mycode}

La función \inlineconsole{up()} se ejecutará cuando realizamos la migración, mientra que la función \inlineconsole{down()} se usará cuando realicemos un “\textbf{\textit{rollback}}”, es decir, echar para atrás una migración.

\section{Opciones de los migraciones}

En la \href{https://laravel.com/docs/10.x/migrations#tables}{documentación oficial} se explican cómo funcionan los \textit{migrations} y las funcionalidades básicas y avanzadas que tienen.

Teniendo en cuenta lo visto en el punto anterior, podemos visualizar que las acciones del \textit{migration} contiene varias líneas, y vamos a destacar lo siguiente:

\begin{itemize}
    \item Crea una tabla llamada “\textbf{users}”, que contiene las siguientes columnas
    \item \textbf{id}: es un alias a un método \textbf{bigIncrements}. Va a generar una columna de tipo integer, que se va a ir incrementando y que va a ser \textbf{clave primaria}.

    \item \textbf{string}: existen varias columnas de tipo “string”, que son “name”, “email” y “password”. Es lo equivalente a “varchar”, sin indicar en este caso el número de longitud. Se le puede indicar como segundo parámetro.
    \item \textbf{unique()}: el contenido de este campo (en el ejemplo el \textbf{email}) debe ser único en la tabla.
    \item \textbf{timestamp}: crea un campo de tipo TIMESTAMP.
    \item \textbf{nullable}: permite que este campo sea \textbf{null}.

    \item \textbf{timestamps}: Este es un método especial que crea dos campos en la base de datos: “\textbf{created\_at”} y “\textbf{updated\_at}”. De esta manera sabemos cuándo se ha creado y modificado el registro en la base de datos.
\end{itemize}

\section{Uso de los migraciones}

Una vez tenemos distintos ficheros de migraciones, hay que saber cómo aplicarlos y qué sucede con ellos. De nuevo, en la \href{https://laravel.com/docs/10.x/migrations#running-migrations}{documentación} aparecen distintos ejemplo, de los cuales se van a destacar sólo unos a continuación:

\subsection{Desplegar migraciones}
Para realizar el despliegue de todas las migraciones debemos ejecutar el siguiente comando:

\begin{mycode}{Ejecutar migraciones}{console}{}
root@1b29e46c10ae:/var/www/html# php artisan migrate
   INFO  Preparing database.
Creating migration table ............................. 52ms DONE

   INFO  Running migrations.
2014_10_12_000000_create_users_table ..............   108ms DONE
2014_10_12_100000_create_password_reset_tokens_table  127ms DONE
2019_08_19_000000_create_failed_jobs_table .........   88ms DONE
2019_12_14_000001_create_personal_access_tokens_table 140ms DONE
2023_09_26_094514_create_posts_table ...............   74ms DONE
\end{mycode}

\subsection{Comprobar estado de las migraciones}

Para comprobar el estado de las migraciones podemos realizarlo de la siguiente manera:
\begin{mycode}{Estado de las migraciones}{console}{}
root@1b29e46c10ae:/var/www/html# php artisan migrate:status

Migration name ................................ Batch / Status
2014_10_12_000000_create_users_table ................. [1] Ran
2014_10_12_100000_create_password_reset_tokens_table . [1] Ran
2019_08_19_000000_create_failed_jobs_table ........... [1] Ran
2019_12_14_000001_create_personal_access_tokens_table  [1] Ran
2023_09_26_094514_create_posts_table ................. [1] Ran
\end{mycode}


Si queremos ver a nivel de base de datos qué ha pasado, podemos ejecutar una sesión y visualizar la propia base de datos. Veremos cómo se ha creado la base de datos, las tablas, y una tabla especial llamada \textbf{migrations}, que contiene qué ficheros se han desplegado.

\begin{mycode}{Ejecutar migraciones}{mysql}{}
root@1b29e46c10ae:/var/www/html# php artisan db

mysql> use example_app;
Database changed

mysql> show tables;
+------------------------+
| Tables_in_example_app  |
+------------------------+
| failed_jobs            |
| migrations             |
| password_reset_tokens  |
| personal_access_tokens |
| posts                  |
| users                  |
+------------------------+
6 rows in set (0.00 sec)

mysql> select * from migrations;
+----+-------------------------------------------------------+-------+
| id | migration                                             | batch |
+----+-------------------------------------------------------+-------+
|  1 | 2014_10_12_000000_create_users_table                  |     1 |
|  2 | 2014_10_12_100000_create_password_reset_tokens_table  |     1 |
|  3 | 2019_08_19_000000_create_failed_jobs_table            |     1 |
|  4 | 2019_12_14_000001_create_personal_access_tokens_table |     1 |
|  5 | 2023_09_26_094514_create_posts_table                  |     1 |
+----+-------------------------------------------------------+-------+
5 rows in set (0.00 sec)
\end{mycode}
